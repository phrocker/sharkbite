// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: hdfs.proto

#include "hdfs.pb.h"

#include <google/protobuf/descriptor.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
#include <google/protobuf/wire_format_lite.h>

#include <algorithm>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_BlockKeyProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_BlockProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_BlockWithLocationsProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_CheckpointCommandProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_CheckpointSignatureProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_DatanodeIDProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_DatanodeInfoProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_ExtendedBlockProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_FileEncryptionInfoProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_FsPermissionProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<3>
        scc_info_HdfsFileStatusProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<3>
        scc_info_LocatedBlockProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_LocatedBlocksProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_NamespaceInfoProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_RemoteEditLogProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<1>
        scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_hdfs_2eproto ::PROTOBUF_NAMESPACE_ID::internal::
    SCCInfo<0>
        scc_info_StorageInfoProto_hdfs_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Security_2eproto ::PROTOBUF_NAMESPACE_ID::
    internal::SCCInfo<0>
        scc_info_TokenProto_Security_2eproto;
namespace Hdfs {
namespace Internal {
class ExtendedBlockProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExtendedBlockProto>
      _instance;
} _ExtendedBlockProto_default_instance_;
class DatanodeIDProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DatanodeIDProto>
      _instance;
} _DatanodeIDProto_default_instance_;
class DatanodeInfosProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DatanodeInfosProto>
      _instance;
} _DatanodeInfosProto_default_instance_;
class DatanodeInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<DatanodeInfoProto>
      _instance;
} _DatanodeInfoProto_default_instance_;
class ContentSummaryProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ContentSummaryProto>
      _instance;
} _ContentSummaryProto_default_instance_;
class CorruptFileBlocksProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      CorruptFileBlocksProto>
      _instance;
} _CorruptFileBlocksProto_default_instance_;
class FsPermissionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FsPermissionProto>
      _instance;
} _FsPermissionProto_default_instance_;
class StorageUuidsProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StorageUuidsProto>
      _instance;
} _StorageUuidsProto_default_instance_;
class LocatedBlockProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LocatedBlockProto>
      _instance;
} _LocatedBlockProto_default_instance_;
class DataEncryptionKeyProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      DataEncryptionKeyProto>
      _instance;
} _DataEncryptionKeyProto_default_instance_;
class FileEncryptionInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      FileEncryptionInfoProto>
      _instance;
} _FileEncryptionInfoProto_default_instance_;
class PerFileEncryptionInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      PerFileEncryptionInfoProto>
      _instance;
} _PerFileEncryptionInfoProto_default_instance_;
class ZoneEncryptionInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      ZoneEncryptionInfoProto>
      _instance;
} _ZoneEncryptionInfoProto_default_instance_;
class CipherOptionProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CipherOptionProto>
      _instance;
} _CipherOptionProto_default_instance_;
class LocatedBlocksProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LocatedBlocksProto>
      _instance;
} _LocatedBlocksProto_default_instance_;
class HdfsFileStatusProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HdfsFileStatusProto>
      _instance;
} _HdfsFileStatusProto_default_instance_;
class FsServerDefaultsProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      FsServerDefaultsProto>
      _instance;
} _FsServerDefaultsProto_default_instance_;
class DirectoryListingProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      DirectoryListingProto>
      _instance;
} _DirectoryListingProto_default_instance_;
class SnapshottableDirectoryStatusProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      SnapshottableDirectoryStatusProto>
      _instance;
} _SnapshottableDirectoryStatusProto_default_instance_;
class SnapshottableDirectoryListingProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      SnapshottableDirectoryListingProto>
      _instance;
} _SnapshottableDirectoryListingProto_default_instance_;
class SnapshotDiffReportEntryProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      SnapshotDiffReportEntryProto>
      _instance;
} _SnapshotDiffReportEntryProto_default_instance_;
class SnapshotDiffReportProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      SnapshotDiffReportProto>
      _instance;
} _SnapshotDiffReportProto_default_instance_;
class StorageInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StorageInfoProto>
      _instance;
} _StorageInfoProto_default_instance_;
class NamenodeRegistrationProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      NamenodeRegistrationProto>
      _instance;
} _NamenodeRegistrationProto_default_instance_;
class CheckpointSignatureProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      CheckpointSignatureProto>
      _instance;
} _CheckpointSignatureProto_default_instance_;
class NamenodeCommandProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NamenodeCommandProto>
      _instance;
} _NamenodeCommandProto_default_instance_;
class CheckpointCommandProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      CheckpointCommandProto>
      _instance;
} _CheckpointCommandProto_default_instance_;
class BlockProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BlockProto>
      _instance;
} _BlockProto_default_instance_;
class BlockWithLocationsProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      BlockWithLocationsProto>
      _instance;
} _BlockWithLocationsProto_default_instance_;
class BlocksWithLocationsProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      BlocksWithLocationsProto>
      _instance;
} _BlocksWithLocationsProto_default_instance_;
class RemoteEditLogProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RemoteEditLogProto>
      _instance;
} _RemoteEditLogProto_default_instance_;
class RemoteEditLogManifestProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      RemoteEditLogManifestProto>
      _instance;
} _RemoteEditLogManifestProto_default_instance_;
class NamespaceInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NamespaceInfoProto>
      _instance;
} _NamespaceInfoProto_default_instance_;
class BlockKeyProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BlockKeyProto>
      _instance;
} _BlockKeyProto_default_instance_;
class ExportedBlockKeysProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<
      ExportedBlockKeysProto>
      _instance;
} _ExportedBlockKeysProto_default_instance_;
class RecoveringBlockProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RecoveringBlockProto>
      _instance;
} _RecoveringBlockProto_default_instance_;
class VersionRequestProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VersionRequestProto>
      _instance;
} _VersionRequestProto_default_instance_;
class VersionResponseProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<VersionResponseProto>
      _instance;
} _VersionResponseProto_default_instance_;
class SnapshotInfoProtoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SnapshotInfoProto>
      _instance;
} _SnapshotInfoProto_default_instance_;
}  // namespace Internal
}  // namespace Hdfs
static void InitDefaultsscc_info_BlockKeyProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_BlockKeyProto_default_instance_;
    new (ptr)::Hdfs::Internal::BlockKeyProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::BlockKeyProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_BlockKeyProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_BlockKeyProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_BlockProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_BlockProto_default_instance_;
    new (ptr)::Hdfs::Internal::BlockProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::BlockProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BlockProto_hdfs_2eproto =
    {{ATOMIC_VAR_INIT(
          ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
      0, 0, InitDefaultsscc_info_BlockProto_hdfs_2eproto},
     {}};

static void InitDefaultsscc_info_BlockWithLocationsProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_BlockWithLocationsProto_default_instance_;
    new (ptr)::Hdfs::Internal::BlockWithLocationsProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::BlockWithLocationsProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_BlockWithLocationsProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_BlockWithLocationsProto_hdfs_2eproto},
        {
            &scc_info_BlockProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_BlocksWithLocationsProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_BlocksWithLocationsProto_default_instance_;
    new (ptr)::Hdfs::Internal::BlocksWithLocationsProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::BlocksWithLocationsProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_BlocksWithLocationsProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_BlocksWithLocationsProto_hdfs_2eproto},
        {
            &scc_info_BlockWithLocationsProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_CheckpointCommandProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_CheckpointCommandProto_default_instance_;
    new (ptr)::Hdfs::Internal::CheckpointCommandProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::CheckpointCommandProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_CheckpointCommandProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_CheckpointCommandProto_hdfs_2eproto},
        {
            &scc_info_CheckpointSignatureProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_CheckpointSignatureProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_CheckpointSignatureProto_default_instance_;
    new (ptr)::Hdfs::Internal::CheckpointSignatureProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::CheckpointSignatureProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_CheckpointSignatureProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_CheckpointSignatureProto_hdfs_2eproto},
        {
            &scc_info_StorageInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_CipherOptionProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_CipherOptionProto_default_instance_;
    new (ptr)::Hdfs::Internal::CipherOptionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::CipherOptionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_CipherOptionProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_CipherOptionProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_ContentSummaryProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_ContentSummaryProto_default_instance_;
    new (ptr)::Hdfs::Internal::ContentSummaryProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::ContentSummaryProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_ContentSummaryProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_ContentSummaryProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_CorruptFileBlocksProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_CorruptFileBlocksProto_default_instance_;
    new (ptr)::Hdfs::Internal::CorruptFileBlocksProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::CorruptFileBlocksProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_CorruptFileBlocksProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_CorruptFileBlocksProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_DataEncryptionKeyProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_DataEncryptionKeyProto_default_instance_;
    new (ptr)::Hdfs::Internal::DataEncryptionKeyProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::DataEncryptionKeyProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_DataEncryptionKeyProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_DataEncryptionKeyProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_DatanodeIDProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_DatanodeIDProto_default_instance_;
    new (ptr)::Hdfs::Internal::DatanodeIDProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::DatanodeIDProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_DatanodeIDProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_DatanodeIDProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_DatanodeInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_DatanodeInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::DatanodeInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::DatanodeInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_DatanodeInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_DatanodeInfoProto_hdfs_2eproto},
        {
            &scc_info_DatanodeIDProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_DatanodeInfosProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_DatanodeInfosProto_default_instance_;
    new (ptr)::Hdfs::Internal::DatanodeInfosProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::DatanodeInfosProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_DatanodeInfosProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_DatanodeInfosProto_hdfs_2eproto},
        {
            &scc_info_DatanodeInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_DirectoryListingProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_DirectoryListingProto_default_instance_;
    new (ptr)::Hdfs::Internal::DirectoryListingProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::DirectoryListingProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_DirectoryListingProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_DirectoryListingProto_hdfs_2eproto},
        {
            &scc_info_HdfsFileStatusProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_ExportedBlockKeysProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_ExportedBlockKeysProto_default_instance_;
    new (ptr)::Hdfs::Internal::ExportedBlockKeysProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::ExportedBlockKeysProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_ExportedBlockKeysProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_ExportedBlockKeysProto_hdfs_2eproto},
        {
            &scc_info_BlockKeyProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_ExtendedBlockProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_ExtendedBlockProto_default_instance_;
    new (ptr)::Hdfs::Internal::ExtendedBlockProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::ExtendedBlockProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_ExtendedBlockProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_ExtendedBlockProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_FileEncryptionInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_FileEncryptionInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::FileEncryptionInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::FileEncryptionInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_FileEncryptionInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_FileEncryptionInfoProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_FsPermissionProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_FsPermissionProto_default_instance_;
    new (ptr)::Hdfs::Internal::FsPermissionProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::FsPermissionProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_FsPermissionProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_FsPermissionProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_FsServerDefaultsProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_FsServerDefaultsProto_default_instance_;
    new (ptr)::Hdfs::Internal::FsServerDefaultsProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::FsServerDefaultsProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_FsServerDefaultsProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_FsServerDefaultsProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_HdfsFileStatusProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_HdfsFileStatusProto_default_instance_;
    new (ptr)::Hdfs::Internal::HdfsFileStatusProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::HdfsFileStatusProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3>
    scc_info_HdfsFileStatusProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         3, 0, InitDefaultsscc_info_HdfsFileStatusProto_hdfs_2eproto},
        {
            &scc_info_FsPermissionProto_hdfs_2eproto.base,
            &scc_info_LocatedBlocksProto_hdfs_2eproto.base,
            &scc_info_FileEncryptionInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_LocatedBlockProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_LocatedBlockProto_default_instance_;
    new (ptr)::Hdfs::Internal::LocatedBlockProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::LocatedBlockProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3>
    scc_info_LocatedBlockProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         3, 0, InitDefaultsscc_info_LocatedBlockProto_hdfs_2eproto},
        {
            &scc_info_ExtendedBlockProto_hdfs_2eproto.base,
            &scc_info_DatanodeInfoProto_hdfs_2eproto.base,
            &scc_info_TokenProto_Security_2eproto.base,
        }};

static void InitDefaultsscc_info_LocatedBlocksProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_LocatedBlocksProto_default_instance_;
    new (ptr)::Hdfs::Internal::LocatedBlocksProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::LocatedBlocksProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_LocatedBlocksProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_LocatedBlocksProto_hdfs_2eproto},
        {
            &scc_info_LocatedBlockProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_NamenodeCommandProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_NamenodeCommandProto_default_instance_;
    new (ptr)::Hdfs::Internal::NamenodeCommandProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::NamenodeCommandProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_NamenodeCommandProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_NamenodeCommandProto_hdfs_2eproto},
        {
            &scc_info_CheckpointCommandProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_NamenodeRegistrationProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_NamenodeRegistrationProto_default_instance_;
    new (ptr)::Hdfs::Internal::NamenodeRegistrationProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::NamenodeRegistrationProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_NamenodeRegistrationProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_NamenodeRegistrationProto_hdfs_2eproto},
        {
            &scc_info_StorageInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_NamespaceInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_NamespaceInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::NamespaceInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::NamespaceInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_NamespaceInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_NamespaceInfoProto_hdfs_2eproto},
        {
            &scc_info_StorageInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_PerFileEncryptionInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr =
        &::Hdfs::Internal::_PerFileEncryptionInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::PerFileEncryptionInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::PerFileEncryptionInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_PerFileEncryptionInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_PerFileEncryptionInfoProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_RecoveringBlockProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_RecoveringBlockProto_default_instance_;
    new (ptr)::Hdfs::Internal::RecoveringBlockProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::RecoveringBlockProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_RecoveringBlockProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_RecoveringBlockProto_hdfs_2eproto},
        {
            &scc_info_LocatedBlockProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_RemoteEditLogManifestProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr =
        &::Hdfs::Internal::_RemoteEditLogManifestProto_default_instance_;
    new (ptr)::Hdfs::Internal::RemoteEditLogManifestProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::RemoteEditLogManifestProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_RemoteEditLogManifestProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_RemoteEditLogManifestProto_hdfs_2eproto},
        {
            &scc_info_RemoteEditLogProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_RemoteEditLogProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_RemoteEditLogProto_default_instance_;
    new (ptr)::Hdfs::Internal::RemoteEditLogProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::RemoteEditLogProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_RemoteEditLogProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_RemoteEditLogProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_SnapshotDiffReportEntryProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr =
        &::Hdfs::Internal::_SnapshotDiffReportEntryProto_default_instance_;
    new (ptr)::Hdfs::Internal::SnapshotDiffReportEntryProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::SnapshotDiffReportEntryProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_SnapshotDiffReportEntryProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_SnapshotDiffReportProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_SnapshotDiffReportProto_default_instance_;
    new (ptr)::Hdfs::Internal::SnapshotDiffReportProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::SnapshotDiffReportProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_SnapshotDiffReportProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_SnapshotDiffReportProto_hdfs_2eproto},
        {
            &scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_SnapshotInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_SnapshotInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::SnapshotInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::SnapshotInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_SnapshotInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_SnapshotInfoProto_hdfs_2eproto},
        {
            &scc_info_FsPermissionProto_hdfs_2eproto.base,
        }};

static void
InitDefaultsscc_info_SnapshottableDirectoryListingProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::
                    _SnapshottableDirectoryListingProto_default_instance_;
    new (ptr)::Hdfs::Internal::SnapshottableDirectoryListingProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::SnapshottableDirectoryListingProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_SnapshottableDirectoryListingProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0,
         InitDefaultsscc_info_SnapshottableDirectoryListingProto_hdfs_2eproto},
        {
            &scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto.base,
        }};

static void
InitDefaultsscc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr =
        &::Hdfs::Internal::_SnapshottableDirectoryStatusProto_default_instance_;
    new (ptr)::Hdfs::Internal::SnapshottableDirectoryStatusProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::SnapshottableDirectoryStatusProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0,
         InitDefaultsscc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto},
        {
            &scc_info_HdfsFileStatusProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_StorageInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_StorageInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::StorageInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::StorageInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_StorageInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_StorageInfoProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_StorageUuidsProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_StorageUuidsProto_default_instance_;
    new (ptr)::Hdfs::Internal::StorageUuidsProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::StorageUuidsProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_StorageUuidsProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_StorageUuidsProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_VersionRequestProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_VersionRequestProto_default_instance_;
    new (ptr)::Hdfs::Internal::VersionRequestProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::VersionRequestProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_VersionRequestProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_VersionRequestProto_hdfs_2eproto},
        {}};

static void InitDefaultsscc_info_VersionResponseProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_VersionResponseProto_default_instance_;
    new (ptr)::Hdfs::Internal::VersionResponseProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::VersionResponseProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1>
    scc_info_VersionResponseProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         1, 0, InitDefaultsscc_info_VersionResponseProto_hdfs_2eproto},
        {
            &scc_info_NamespaceInfoProto_hdfs_2eproto.base,
        }};

static void InitDefaultsscc_info_ZoneEncryptionInfoProto_hdfs_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Hdfs::Internal::_ZoneEncryptionInfoProto_default_instance_;
    new (ptr)::Hdfs::Internal::ZoneEncryptionInfoProto();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Hdfs::Internal::ZoneEncryptionInfoProto::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0>
    scc_info_ZoneEncryptionInfoProto_hdfs_2eproto = {
        {ATOMIC_VAR_INIT(
             ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized),
         0, 0, InitDefaultsscc_info_ZoneEncryptionInfoProto_hdfs_2eproto},
        {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_hdfs_2eproto[39];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
    file_level_enum_descriptors_hdfs_2eproto[9];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const**
    file_level_service_descriptors_hdfs_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32
    TableStruct_hdfs_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto, poolid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto, blockid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto,
                              generationstamp_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExtendedBlockProto, numbytes_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, ipaddr_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, hostname_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, datanodeuuid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, xferport_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, infoport_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto, ipcport_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeIDProto,
                              infosecureport_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfosProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfosProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfosProto, datanodes_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, id_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, capacity_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, dfsused_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, remaining_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto,
                              blockpoolused_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, lastupdate_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto,
                              xceivercount_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, location_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, adminstate_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto,
                              cachecapacity_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DatanodeInfoProto, cacheused_),
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        0,
        8,
        9,
        10,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto, length_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              filecount_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              directorycount_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto, quota_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              spaceconsumed_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ContentSummaryProto,
                              spacequota_),
        0,
        1,
        2,
        3,
        4,
        5,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CorruptFileBlocksProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CorruptFileBlocksProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CorruptFileBlocksProto, files_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CorruptFileBlocksProto,
                              cookie_),
        ~0u,
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsPermissionProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsPermissionProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsPermissionProto, perm_),
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageUuidsProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageUuidsProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageUuidsProto,
                              storageuuids_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, b_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, offset_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, locs_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, corrupt_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, blocktoken_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, iscached_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto,
                              storagetypes_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlockProto, storageids_),
        0,
        2,
        ~0u,
        3,
        1,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto, keyid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              blockpoolid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto, nonce_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              encryptionkey_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              expirydate_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DataEncryptionKeyProto,
                              encryptionalgorithm_),
        5,
        0,
        1,
        2,
        4,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              suite_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              cryptoprotocolversion_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto, key_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto, iv_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              keyname_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FileEncryptionInfoProto,
                              ezkeyversionname_),
        4,
        5,
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::PerFileEncryptionInfoProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::PerFileEncryptionInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::PerFileEncryptionInfoProto,
                              key_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::PerFileEncryptionInfoProto,
                              iv_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::PerFileEncryptionInfoProto,
                              ezkeyversionname_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ZoneEncryptionInfoProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ZoneEncryptionInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ZoneEncryptionInfoProto,
                              suite_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ZoneEncryptionInfoProto,
                              cryptoprotocolversion_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ZoneEncryptionInfoProto,
                              keyname_),
        1,
        2,
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, suite_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, inkey_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, iniv_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, outkey_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CipherOptionProto, outiv_),
        4,
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto,
                              filelength_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto, blocks_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto,
                              underconstruction_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto, lastblock_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::LocatedBlocksProto,
                              islastblockcomplete_),
        1,
        ~0u,
        2,
        0,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, filetype_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, path_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, length_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              permission_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, owner_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, group_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              modification_time_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              access_time_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, symlink_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              block_replication_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              blocksize_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              locations_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto, fileid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              childrennum_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::HdfsFileStatusProto,
                              fileencryptioninfo_),
        13,
        0,
        7,
        4,
        1,
        2,
        8,
        9,
        3,
        12,
        10,
        5,
        11,
        14,
        6,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              blocksize_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              bytesperchecksum_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              writepacketsize_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              replication_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              filebuffersize_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              encryptdatatransfer_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              trashinterval_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::FsServerDefaultsProto,
                              checksumtype_),
        0,
        1,
        2,
        3,
        4,
        6,
        5,
        7,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DirectoryListingProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DirectoryListingProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DirectoryListingProto,
                              partiallisting_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::DirectoryListingProto,
                              remainingentries_),
        ~0u,
        0,
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto,
            _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto, dirstatus_),
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto,
            snapshot_quota_),
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto,
            snapshot_number_),
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryStatusProto,
            parent_fullpath_),
        1,
        2,
        3,
        0,
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryListingProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryListingProto,
            _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(
            ::Hdfs::Internal::SnapshottableDirectoryListingProto,
            snapshottabledirlisting_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportEntryProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportEntryProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportEntryProto,
                              fullpath_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportEntryProto,
                              modificationlabel_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              snapshotroot_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              fromsnapshot_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              tosnapshot_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotDiffReportProto,
                              diffreportentries_),
        0,
        1,
        2,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto,
                              layoutversion_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto, namespceid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto, clusterid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::StorageInfoProto, ctime_),
        1,
        2,
        0,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              rpcaddress_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              httpaddress_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              storageinfo_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeRegistrationProto,
                              role_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              blockpoolid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              mostrecentcheckpointtxid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              cursegmenttxid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointSignatureProto,
                              storageinfo_),
        0,
        2,
        3,
        1,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeCommandProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeCommandProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeCommandProto, action_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeCommandProto, type_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamenodeCommandProto,
                              checkpointcmd_),
        1,
        2,
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointCommandProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointCommandProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointCommandProto,
                              signature_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::CheckpointCommandProto,
                              needtoreturnimage_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockProto, blockid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockProto, genstamp_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockProto, numbytes_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockWithLocationsProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockWithLocationsProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockWithLocationsProto,
                              block_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockWithLocationsProto,
                              datanodeuuids_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockWithLocationsProto,
                              storageuuids_),
        0,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlocksWithLocationsProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlocksWithLocationsProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlocksWithLocationsProto,
                              blocks_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogProto, starttxid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogProto, endtxid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogProto,
                              isinprogress_),
        0,
        1,
        2,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogManifestProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogManifestProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RemoteEditLogManifestProto,
                              logs_),
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto,
                              buildversion_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto, unused_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto,
                              blockpoolid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto,
                              storageinfo_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::NamespaceInfoProto,
                              softwareversion_),
        0,
        4,
        1,
        3,
        2,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockKeyProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockKeyProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockKeyProto, keyid_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockKeyProto, expirydate_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::BlockKeyProto, keybytes_),
        2,
        1,
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              isblocktokenenabled_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              keyupdateinterval_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              tokenlifetime_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              currentkey_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::ExportedBlockKeysProto,
                              allkeys_),
        3,
        1,
        2,
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RecoveringBlockProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RecoveringBlockProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RecoveringBlockProto,
                              newgenstamp_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::RecoveringBlockProto, block_),
        1,
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::VersionRequestProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::VersionRequestProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::VersionResponseProto,
                              _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::VersionResponseProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::VersionResponseProto, info_),
        0,
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto, _has_bits_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto,
                              _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto,
                              snapshotname_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto,
                              snapshotroot_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto, permission_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto, owner_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto, group_),
        PROTOBUF_FIELD_OFFSET(::Hdfs::Internal::SnapshotInfoProto, createtime_),
        0,
        1,
        5,
        2,
        3,
        4,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, 9, sizeof(::Hdfs::Internal::ExtendedBlockProto)},
        {13, 25, sizeof(::Hdfs::Internal::DatanodeIDProto)},
        {32, 38, sizeof(::Hdfs::Internal::DatanodeInfosProto)},
        {39, 55, sizeof(::Hdfs::Internal::DatanodeInfoProto)},
        {66, 77, sizeof(::Hdfs::Internal::ContentSummaryProto)},
        {83, 90, sizeof(::Hdfs::Internal::CorruptFileBlocksProto)},
        {92, 98, sizeof(::Hdfs::Internal::FsPermissionProto)},
        {99, 105, sizeof(::Hdfs::Internal::StorageUuidsProto)},
        {106, 119, sizeof(::Hdfs::Internal::LocatedBlockProto)},
        {127, 138, sizeof(::Hdfs::Internal::DataEncryptionKeyProto)},
        {144, 155, sizeof(::Hdfs::Internal::FileEncryptionInfoProto)},
        {161, 169, sizeof(::Hdfs::Internal::PerFileEncryptionInfoProto)},
        {172, 180, sizeof(::Hdfs::Internal::ZoneEncryptionInfoProto)},
        {183, 193, sizeof(::Hdfs::Internal::CipherOptionProto)},
        {198, 208, sizeof(::Hdfs::Internal::LocatedBlocksProto)},
        {213, 233, sizeof(::Hdfs::Internal::HdfsFileStatusProto)},
        {248, 261, sizeof(::Hdfs::Internal::FsServerDefaultsProto)},
        {269, 276, sizeof(::Hdfs::Internal::DirectoryListingProto)},
        {278, 287, sizeof(::Hdfs::Internal::SnapshottableDirectoryStatusProto)},
        {291, 297,
         sizeof(::Hdfs::Internal::SnapshottableDirectoryListingProto)},
        {298, 305, sizeof(::Hdfs::Internal::SnapshotDiffReportEntryProto)},
        {307, 316, sizeof(::Hdfs::Internal::SnapshotDiffReportProto)},
        {320, 329, sizeof(::Hdfs::Internal::StorageInfoProto)},
        {333, 342, sizeof(::Hdfs::Internal::NamenodeRegistrationProto)},
        {346, 355, sizeof(::Hdfs::Internal::CheckpointSignatureProto)},
        {359, 367, sizeof(::Hdfs::Internal::NamenodeCommandProto)},
        {370, 377, sizeof(::Hdfs::Internal::CheckpointCommandProto)},
        {379, 387, sizeof(::Hdfs::Internal::BlockProto)},
        {390, 398, sizeof(::Hdfs::Internal::BlockWithLocationsProto)},
        {401, 407, sizeof(::Hdfs::Internal::BlocksWithLocationsProto)},
        {408, 416, sizeof(::Hdfs::Internal::RemoteEditLogProto)},
        {419, 425, sizeof(::Hdfs::Internal::RemoteEditLogManifestProto)},
        {426, 436, sizeof(::Hdfs::Internal::NamespaceInfoProto)},
        {441, 449, sizeof(::Hdfs::Internal::BlockKeyProto)},
        {452, 462, sizeof(::Hdfs::Internal::ExportedBlockKeysProto)},
        {467, 474, sizeof(::Hdfs::Internal::RecoveringBlockProto)},
        {476, 481, sizeof(::Hdfs::Internal::VersionRequestProto)},
        {481, 487, sizeof(::Hdfs::Internal::VersionResponseProto)},
        {488, 499, sizeof(::Hdfs::Internal::SnapshotInfoProto)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const* const file_default_instances[] =
    {
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_ExtendedBlockProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_DatanodeIDProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_DatanodeInfosProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_DatanodeInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_ContentSummaryProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_CorruptFileBlocksProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_FsPermissionProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_StorageUuidsProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_LocatedBlockProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_DataEncryptionKeyProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_FileEncryptionInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_PerFileEncryptionInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_ZoneEncryptionInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_CipherOptionProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_LocatedBlocksProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_HdfsFileStatusProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_FsServerDefaultsProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_DirectoryListingProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::
                _SnapshottableDirectoryStatusProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::
                _SnapshottableDirectoryListingProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_SnapshotDiffReportEntryProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_SnapshotDiffReportProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_StorageInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_NamenodeRegistrationProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_CheckpointSignatureProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_NamenodeCommandProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_CheckpointCommandProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_BlockProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_BlockWithLocationsProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_BlocksWithLocationsProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_RemoteEditLogProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_RemoteEditLogManifestProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_NamespaceInfoProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_BlockKeyProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_ExportedBlockKeysProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_RecoveringBlockProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_VersionRequestProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_VersionResponseProto_default_instance_),
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(
            &::Hdfs::Internal::_SnapshotInfoProto_default_instance_),
};

const char descriptor_table_protodef_hdfs_2eproto[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) =
    "\n\nhdfs.proto\022\rHdfs.Internal\032\016Security.pr"
    "oto\"c\n\022ExtendedBlockProto\022\016\n\006poolId\030\001 \002("
    "\t\022\017\n\007blockId\030\002 "
    "\002(\004\022\027\n\017generationStamp\030\003 "
    "\002(\004\022\023\n\010numBytes\030\004 "
    "\001(\004:\0010\"\231\001\n\017DatanodeIDP"
    "roto\022\016\n\006ipAddr\030\001 \002(\t\022\020\n\010hostName\030\002 "
    "\002(\t\022\024"
    "\n\014datanodeUuid\030\003 \002(\t\022\020\n\010xferPort\030\004 "
    "\002(\r\022\020"
    "\n\010infoPort\030\005 \002(\r\022\017\n\007ipcPort\030\006 "
    "\002(\r\022\031\n\016inf"
    "oSecurePort\030\007 \001(\r:\0010\"I\n\022DatanodeInfosPro"
    "to\0223\n\tdatanodes\030\001 \003(\0132 .Hdfs.Internal.Da"
    "tanodeInfoProto\"\236\003\n\021DatanodeInfoProto\022*\n"
    "\002id\030\001 \002(\0132\036.Hdfs.Internal.DatanodeIDProt"
    "o\022\023\n\010capacity\030\002 "
    "\001(\004:\0010\022\022\n\007dfsUsed\030\003 \001(\004:"
    "\0010\022\024\n\tremaining\030\004 \001(\004:\0010\022\030\n\rblockPoolUse"
    "d\030\005 \001(\004:\0010\022\025\n\nlastUpdate\030\006 "
    "\001(\004:\0010\022\027\n\014xce"
    "iverCount\030\007 \001(\r:\0010\022\020\n\010location\030\010 "
    "\001(\t\022G\n\n"
    "adminState\030\n \001(\0162+.Hdfs.Internal.Datanod"
    "eInfoProto.AdminState:\006NORMAL\022\030\n\rcacheCa"
    "pacity\030\013 \001(\004:\0010\022\024\n\tcacheUsed\030\014 "
    "\001(\004:\0010\"I\n"
    "\nAdminState\022\n\n\006NORMAL\020\000\022\033\n\027DECOMMISSION_"
    "INPROGRESS\020\001\022\022\n\016DECOMMISSIONED\020\002\"\212\001\n\023Con"
    "tentSummaryProto\022\016\n\006length\030\001 \002(\004\022\021\n\tfile"
    "Count\030\002 \002(\004\022\026\n\016directoryCount\030\003 "
    "\002(\004\022\r\n\005q"
    "uota\030\004 \002(\004\022\025\n\rspaceConsumed\030\005 "
    "\002(\004\022\022\n\nspa"
    "ceQuota\030\006 \002(\004\"7\n\026CorruptFileBlocksProto\022"
    "\r\n\005files\030\001 \003(\t\022\016\n\006cookie\030\002 "
    "\002(\t\"!\n\021FsPerm"
    "issionProto\022\014\n\004perm\030\001 \002(\r\")\n\021StorageUuid"
    "sProto\022\024\n\014storageUuids\030\001 \003(\t\"\242\002\n\021Located"
    "BlockProto\022,\n\001b\030\001 \002(\0132!.Hdfs.Internal.Ex"
    "tendedBlockProto\022\016\n\006offset\030\002 \002(\004\022.\n\004locs"
    "\030\003 \003(\0132 .Hdfs.Internal.DatanodeInfoProto"
    "\022\017\n\007corrupt\030\004 \002(\010\022-\n\nblockToken\030\005 "
    "\002(\0132\031."
    "Hdfs.Internal.TokenProto\022\024\n\010isCached\030\006 \003"
    "(\010B\002\020\001\0225\n\014storageTypes\030\007 \003(\0162\037.Hdfs.Inte"
    "rnal.StorageTypeProto\022\022\n\nstorageIDs\030\010 \003("
    "\t\"\223\001\n\026DataEncryptionKeyProto\022\r\n\005keyId\030\001 "
    "\002(\r\022\023\n\013blockPoolId\030\002 \002(\t\022\r\n\005nonce\030\003 "
    "\002(\014\022"
    "\025\n\rencryptionKey\030\004 \002(\014\022\022\n\nexpiryDate\030\005 \002"
    "(\004\022\033\n\023encryptionAlgorithm\030\006 \001(\t\"\327\001\n\027File"
    "EncryptionInfoProto\022.\n\005suite\030\001 \002(\0162\037.Hdf"
    "s.Internal.CipherSuiteProto\022H\n\025cryptoPro"
    "tocolVersion\030\002 \002(\0162).Hdfs.Internal.Crypt"
    "oProtocolVersionProto\022\013\n\003key\030\003 \002(\014\022\n\n\002iv"
    "\030\004 \002(\014\022\017\n\007keyName\030\005 "
    "\002(\t\022\030\n\020ezKeyVersionN"
    "ame\030\006 \002(\t\"O\n\032PerFileEncryptionInfoProto\022"
    "\013\n\003key\030\001 \002(\014\022\n\n\002iv\030\002 "
    "\002(\014\022\030\n\020ezKeyVersion"
    "Name\030\003 \002(\t\"\244\001\n\027ZoneEncryptionInfoProto\022."
    "\n\005suite\030\001 \002(\0162\037.Hdfs.Internal.CipherSuit"
    "eProto\022H\n\025cryptoProtocolVersion\030\002 \002(\0162)."
    "Hdfs.Internal.CryptoProtocolVersionProto"
    "\022\017\n\007keyName\030\003 \002(\t\"\177\n\021CipherOptionProto\022."
    "\n\005suite\030\001 \002(\0162\037.Hdfs.Internal.CipherSuit"
    "eProto\022\r\n\005inKey\030\002 \001(\014\022\014\n\004inIv\030\003 "
    "\001(\014\022\016\n\006o"
    "utKey\030\004 \001(\014\022\r\n\005outIv\030\005 "
    "\001(\014\"\307\001\n\022LocatedBl"
    "ocksProto\022\022\n\nfileLength\030\001 \002(\004\0220\n\006blocks\030"
    "\002 \003(\0132 .Hdfs.Internal.LocatedBlockProto\022"
    "\031\n\021underConstruction\030\003 \002(\010\0223\n\tlastBlock\030"
    "\004 \001(\0132 .Hdfs.Internal.LocatedBlockProto\022"
    "\033\n\023isLastBlockComplete\030\005 \002(\010\"\226\004\n\023HdfsFil"
    "eStatusProto\022=\n\010fileType\030\001 \002(\0162+.Hdfs.In"
    "ternal.HdfsFileStatusProto.FileType\022\014\n\004p"
    "ath\030\002 \002(\014\022\016\n\006length\030\003 "
    "\002(\004\0224\n\npermission\030"
    "\004 \002(\0132 .Hdfs.Internal.FsPermissionProto\022"
    "\r\n\005owner\030\005 \002(\t\022\r\n\005group\030\006 "
    "\002(\t\022\031\n\021modific"
    "ation_time\030\007 \002(\004\022\023\n\013access_time\030\010 "
    "\002(\004\022\017\n"
    "\007symlink\030\t \001(\014\022\034\n\021block_replication\030\n \001("
    "\r:\0010\022\024\n\tblocksize\030\013 "
    "\001(\004:\0010\0224\n\tlocations\030"
    "\014 \001(\0132!.Hdfs.Internal.LocatedBlocksProto"
    "\022\021\n\006fileId\030\r "
    "\001(\004:\0010\022\027\n\013childrenNum\030\016 \001(\005"
    ":\002-1\022B\n\022fileEncryptionInfo\030\017 \001(\0132&.Hdfs."
    "Internal.FileEncryptionInfoProto\"3\n\010File"
    "Type\022\n\n\006IS_DIR\020\001\022\013\n\007IS_FILE\020\002\022\016\n\nIS_"
    "SYML"
    "INK\020\003\"\220\002\n\025FsServerDefaultsProto\022\021\n\tblock"
    "Size\030\001 \002(\004\022\030\n\020bytesPerChecksum\030\002 "
    "\002(\r\022\027\n\017"
    "writePacketSize\030\003 \002(\r\022\023\n\013replication\030\004 \002"
    "(\r\022\026\n\016fileBufferSize\030\005 \002(\r\022\"\n\023encryptDat"
    "aTransfer\030\006 \001(\010:\005false\022\030\n\rtrashInterval\030"
    "\007 \001(\004:\0010\022F\n\014checksumType\030\010 \001(\0162 .Hdfs.In"
    "ternal.ChecksumTypeProto:\016CHECKSUM_CRC32"
    "\"m\n\025DirectoryListingProto\022:\n\016partialList"
    "ing\030\001 \003(\0132\".Hdfs.Internal.HdfsFileStatus"
    "Proto\022\030\n\020remainingEntries\030\002 \002(\r\"\244\001\n!Snap"
    "shottableDirectoryStatusProto\0225\n\tdirStat"
    "us\030\001 \002(\0132\".Hdfs.Internal.HdfsFileStatusP"
    "roto\022\026\n\016snapshot_quota\030\002 \002(\r\022\027\n\017snapshot"
    "_number\030\003 \002(\r\022\027\n\017parent_fullpath\030\004 \002(\014\"w"
    "\n\"SnapshottableDirectoryListingProto\022Q\n\027"
    "snapshottableDirListing\030\001 \003(\01320.Hdfs.Int"
    "ernal.SnapshottableDirectoryStatusProto\""
    "K\n\034SnapshotDiffReportEntryProto\022\020\n\010fullp"
    "ath\030\001 \002(\014\022\031\n\021modificationLabel\030\002 "
    "\002(\t\"\241\001\n"
    "\027SnapshotDiffReportProto\022\024\n\014snapshotRoot"
    "\030\001 \002(\t\022\024\n\014fromSnapshot\030\002 "
    "\002(\t\022\022\n\ntoSnapsh"
    "ot\030\003 \002(\t\022F\n\021diffReportEntries\030\004 \003(\0132+.Hd"
    "fs.Internal.SnapshotDiffReportEntryProto"
    "\"_\n\020StorageInfoProto\022\025\n\rlayoutVersion\030\001 "
    "\002(\r\022\022\n\nnamespceID\030\002 "
    "\002(\r\022\021\n\tclusterID\030\003 \002"
    "(\t\022\r\n\005cTime\030\004 \002(\004\"\215\002\n\031NamenodeRegistrati"
    "onProto\022\022\n\nrpcAddress\030\001 \002(\t\022\023\n\013httpAddre"
    "ss\030\002 \002(\t\0224\n\013storageInfo\030\003 \002(\0132\037.Hdfs.Int"
    "ernal.StorageInfoProto\022R\n\004role\030\004 \001(\0162:.H"
    "dfs.Internal.NamenodeRegistrationProto.N"
    "amenodeRoleProto:\010NAMENODE\"=\n\021NamenodeRo"
    "leProto\022\014\n\010NAMENODE\020\001\022\n\n\006BACKUP\020\002\022\016\n"
    "\nCHE"
    "CKPOINT\020\003\"\237\001\n\030CheckpointSignatureProto\022\023"
    "\n\013blockPoolId\030\001 \002(\t\022 \n\030mostRecentCheckpo"
    "intTxId\030\002 \002(\004\022\026\n\016curSegmentTxId\030\003 "
    "\002(\004\0224\n"
    "\013storageInfo\030\004 \002(\0132\037.Hdfs.Internal.Stora"
    "geInfoProto\"\320\001\n\024NamenodeCommandProto\022\016\n\006"
    "action\030\001 \002(\r\0226\n\004type\030\002 \002(\0162(.Hdfs.Intern"
    "al.NamenodeCommandProto.Type\022<\n\rcheckpoi"
    "ntCmd\030\003 \001(\0132%.Hdfs.Internal.CheckpointCo"
    "mmandProto\"2\n\004Type\022\023\n\017NamenodeCommand\020\000\022"
    "\025\n\021CheckPointCommand\020\001\"o\n\026CheckpointComm"
    "andProto\022:\n\tsignature\030\001 \002(\0132\'.Hdfs.Inter"
    "nal.CheckpointSignatureProto\022\031\n\021needToRe"
    "turnImage\030\002 \002(\010\"D\n\nBlockProto\022\017\n\007blockId"
    "\030\001 \002(\004\022\020\n\010genStamp\030\002 "
    "\002(\004\022\023\n\010numBytes\030\003 \001"
    "(\004:\0010\"p\n\027BlockWithLocationsProto\022(\n\005bloc"
    "k\030\001 \002(\0132\031.Hdfs.Internal.BlockProto\022\025\n\rda"
    "tanodeUuids\030\002 \003(\t\022\024\n\014storageUuids\030\003 \003(\t\""
    "R\n\030BlocksWithLocationsProto\0226\n\006blocks\030\001 "
    "\003(\0132&.Hdfs.Internal.BlockWithLocationsPr"
    "oto\"U\n\022RemoteEditLogProto\022\021\n\tstartTxId\030\001"
    " \002(\004\022\017\n\007endTxId\030\002 "
    "\002(\004\022\033\n\014isInProgress\030\003 "
    "\001(\010:\005false\"M\n\032RemoteEditLogManifestProto"
    "\022/\n\004logs\030\001 \003(\0132!.Hdfs.Internal.RemoteEdi"
    "tLogProto\"\236\001\n\022NamespaceInfoProto\022\024\n\014buil"
    "dVersion\030\001 \002(\t\022\016\n\006unused\030\002 "
    "\002(\r\022\023\n\013blockP"
    "oolID\030\003 \002(\t\0224\n\013storageInfo\030\004 \002(\0132\037.Hdfs."
    "Internal.StorageInfoProto\022\027\n\017softwareVer"
    "sion\030\005 \002(\t\"D\n\rBlockKeyProto\022\r\n\005keyId\030\001 \002"
    "(\r\022\022\n\nexpiryDate\030\002 \002(\004\022\020\n\010keyBytes\030\003 "
    "\001(\014"
    "\"\310\001\n\026ExportedBlockKeysProto\022\033\n\023isBlockTo"
    "kenEnabled\030\001 \002(\010\022\031\n\021keyUpdateInterval\030\002 "
    "\002(\004\022\025\n\rtokenLifeTime\030\003 \002(\004\0220\n\ncurrentKey"
    "\030\004 \002(\0132\034.Hdfs.Internal.BlockKeyProto\022-\n\007"
    "allKeys\030\005 \003(\0132\034.Hdfs.Internal.BlockKeyPr"
    "oto\"\\\n\024RecoveringBlockProto\022\023\n\013newGenSta"
    "mp\030\001 \002(\004\022/\n\005block\030\002 \002(\0132 .Hdfs.Internal."
    "LocatedBlockProto\"\025\n\023VersionRequestProto"
    "\"G\n\024VersionResponseProto\022/\n\004info\030\001 \002(\0132!"
    ".Hdfs.Internal.NamespaceInfoProto\"\247\001\n\021Sn"
    "apshotInfoProto\022\024\n\014snapshotName\030\001 \002(\t\022\024\n"
    "\014snapshotRoot\030\002 \002(\t\0224\n\npermission\030\003 \002(\0132"
    " .Hdfs.Internal.FsPermissionProto\022\r\n\005own"
    "er\030\004 \002(\t\022\r\n\005group\030\005 "
    "\002(\t\022\022\n\ncreateTime\030\006 "
    "\002(\t*%\n\020StorageTypeProto\022\010\n\004DISK\020\001\022\007\n\003SSD"
    "\020\002*"
    "6\n\020CipherSuiteProto\022\013\n\007UNKNOWN\020\001\022\025\n\021A"
    "ES_CTR_NOPADDING\020\002*P\n\032CryptoProtocolVers"
    "ionProto\022\034\n\030UNKNOWN_PROTOCOL_VERSION\020\001\022\024"
    "\n\020ENCRYPTION_ZONES\020\002*O\n\021ChecksumTypeProt"
    "o\022\021\n\rCHECKSUM_NULL\020\000\022\022\n\016CHECKSUM_CRC32\020\001"
    "\022\023\n\017CHECKSUM_CRC32C\020\002*L\n\021ReplicaStatePro"
    "to\022\r\n\tFINALIZED\020\000\022\007\n\003RBW\020\001\022\007\n\003RWR"
    "\020\002\022\007\n\003R"
    "UR\020\003\022\r\n\tTEMPORARY\020\004B6\n%org.apache.hadoop"
    ".hdfs.protocol.protoB\nHdfsProtos\240\001\001";
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* const
    descriptor_table_hdfs_2eproto_deps[1] = {
        &::descriptor_table_Security_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase* const
    descriptor_table_hdfs_2eproto_sccs[39] = {
        &scc_info_BlockKeyProto_hdfs_2eproto.base,
        &scc_info_BlockProto_hdfs_2eproto.base,
        &scc_info_BlockWithLocationsProto_hdfs_2eproto.base,
        &scc_info_BlocksWithLocationsProto_hdfs_2eproto.base,
        &scc_info_CheckpointCommandProto_hdfs_2eproto.base,
        &scc_info_CheckpointSignatureProto_hdfs_2eproto.base,
        &scc_info_CipherOptionProto_hdfs_2eproto.base,
        &scc_info_ContentSummaryProto_hdfs_2eproto.base,
        &scc_info_CorruptFileBlocksProto_hdfs_2eproto.base,
        &scc_info_DataEncryptionKeyProto_hdfs_2eproto.base,
        &scc_info_DatanodeIDProto_hdfs_2eproto.base,
        &scc_info_DatanodeInfoProto_hdfs_2eproto.base,
        &scc_info_DatanodeInfosProto_hdfs_2eproto.base,
        &scc_info_DirectoryListingProto_hdfs_2eproto.base,
        &scc_info_ExportedBlockKeysProto_hdfs_2eproto.base,
        &scc_info_ExtendedBlockProto_hdfs_2eproto.base,
        &scc_info_FileEncryptionInfoProto_hdfs_2eproto.base,
        &scc_info_FsPermissionProto_hdfs_2eproto.base,
        &scc_info_FsServerDefaultsProto_hdfs_2eproto.base,
        &scc_info_HdfsFileStatusProto_hdfs_2eproto.base,
        &scc_info_LocatedBlockProto_hdfs_2eproto.base,
        &scc_info_LocatedBlocksProto_hdfs_2eproto.base,
        &scc_info_NamenodeCommandProto_hdfs_2eproto.base,
        &scc_info_NamenodeRegistrationProto_hdfs_2eproto.base,
        &scc_info_NamespaceInfoProto_hdfs_2eproto.base,
        &scc_info_PerFileEncryptionInfoProto_hdfs_2eproto.base,
        &scc_info_RecoveringBlockProto_hdfs_2eproto.base,
        &scc_info_RemoteEditLogManifestProto_hdfs_2eproto.base,
        &scc_info_RemoteEditLogProto_hdfs_2eproto.base,
        &scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto.base,
        &scc_info_SnapshotDiffReportProto_hdfs_2eproto.base,
        &scc_info_SnapshotInfoProto_hdfs_2eproto.base,
        &scc_info_SnapshottableDirectoryListingProto_hdfs_2eproto.base,
        &scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto.base,
        &scc_info_StorageInfoProto_hdfs_2eproto.base,
        &scc_info_StorageUuidsProto_hdfs_2eproto.base,
        &scc_info_VersionRequestProto_hdfs_2eproto.base,
        &scc_info_VersionResponseProto_hdfs_2eproto.base,
        &scc_info_ZoneEncryptionInfoProto_hdfs_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag
    descriptor_table_hdfs_2eproto_once;
static bool descriptor_table_hdfs_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_hdfs_2eproto = {
        &descriptor_table_hdfs_2eproto_initialized,
        descriptor_table_protodef_hdfs_2eproto,
        "hdfs.proto",
        6235,
        &descriptor_table_hdfs_2eproto_once,
        descriptor_table_hdfs_2eproto_sccs,
        descriptor_table_hdfs_2eproto_deps,
        39,
        1,
        schemas,
        file_default_instances,
        TableStruct_hdfs_2eproto::offsets,
        file_level_metadata_hdfs_2eproto,
        39,
        file_level_enum_descriptors_hdfs_2eproto,
        file_level_service_descriptors_hdfs_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_hdfs_2eproto =
    (::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(
         &descriptor_table_hdfs_2eproto),
     true);
namespace Hdfs {
namespace Internal {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DatanodeInfoProto_AdminState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[0];
}
bool DatanodeInfoProto_AdminState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto::NORMAL;
constexpr DatanodeInfoProto_AdminState
    DatanodeInfoProto::DECOMMISSION_INPROGRESS;
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto::DECOMMISSIONED;
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MIN;
constexpr DatanodeInfoProto_AdminState DatanodeInfoProto::AdminState_MAX;
constexpr int DatanodeInfoProto::AdminState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
HdfsFileStatusProto_FileType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[1];
}
bool HdfsFileStatusProto_FileType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_DIR;
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_FILE;
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto::IS_SYMLINK;
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto::FileType_MIN;
constexpr HdfsFileStatusProto_FileType HdfsFileStatusProto::FileType_MAX;
constexpr int HdfsFileStatusProto::FileType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NamenodeRegistrationProto_NamenodeRoleProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[2];
}
bool NamenodeRegistrationProto_NamenodeRoleProto_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr NamenodeRegistrationProto_NamenodeRoleProto
    NamenodeRegistrationProto::NAMENODE;
constexpr NamenodeRegistrationProto_NamenodeRoleProto
    NamenodeRegistrationProto::BACKUP;
constexpr NamenodeRegistrationProto_NamenodeRoleProto
    NamenodeRegistrationProto::CHECKPOINT;
constexpr NamenodeRegistrationProto_NamenodeRoleProto
    NamenodeRegistrationProto::NamenodeRoleProto_MIN;
constexpr NamenodeRegistrationProto_NamenodeRoleProto
    NamenodeRegistrationProto::NamenodeRoleProto_MAX;
constexpr int NamenodeRegistrationProto::NamenodeRoleProto_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NamenodeCommandProto_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[3];
}
bool NamenodeCommandProto_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr NamenodeCommandProto_Type NamenodeCommandProto::NamenodeCommand;
constexpr NamenodeCommandProto_Type NamenodeCommandProto::CheckPointCommand;
constexpr NamenodeCommandProto_Type NamenodeCommandProto::Type_MIN;
constexpr NamenodeCommandProto_Type NamenodeCommandProto::Type_MAX;
constexpr int NamenodeCommandProto::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StorageTypeProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[4];
}
bool StorageTypeProto_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CipherSuiteProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[5];
}
bool CipherSuiteProto_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CryptoProtocolVersionProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[6];
}
bool CryptoProtocolVersionProto_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChecksumTypeProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[7];
}
bool ChecksumTypeProto_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplicaStateProto_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_hdfs_2eproto);
  return file_level_enum_descriptors_hdfs_2eproto[8];
}
bool ReplicaStateProto_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

// ===================================================================

void ExtendedBlockProto::InitAsDefaultInstance() {}
class ExtendedBlockProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtendedBlockProto>()._has_bits_);
  static void set_has_poolid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_blockid(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_generationstamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numbytes(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
};

ExtendedBlockProto::ExtendedBlockProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.ExtendedBlockProto)
}
ExtendedBlockProto::ExtendedBlockProto(const ExtendedBlockProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  poolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_poolid()) {
    poolid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.poolid_);
  }
  ::memcpy(&blockid_, &from.blockid_,
           static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                               reinterpret_cast<char*>(&blockid_)) +
               sizeof(numbytes_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.ExtendedBlockProto)
}

void ExtendedBlockProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_ExtendedBlockProto_hdfs_2eproto.base);
  poolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&blockid_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                               reinterpret_cast<char*>(&blockid_)) +
               sizeof(numbytes_));
}

ExtendedBlockProto::~ExtendedBlockProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.ExtendedBlockProto)
  SharedDtor();
}

void ExtendedBlockProto::SharedDtor() {
  poolid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ExtendedBlockProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ExtendedBlockProto& ExtendedBlockProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_ExtendedBlockProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void ExtendedBlockProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.ExtendedBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    poolid_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&blockid_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                                 reinterpret_cast<char*>(&blockid_)) +
                 sizeof(numbytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ExtendedBlockProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string poolId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_poolid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.ExtendedBlockProto.poolId");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 blockId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_blockid(&has_bits);
          blockid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 generationStamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_generationstamp(&has_bits);
          generationstamp_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 numBytes = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_numbytes(&has_bits);
          numbytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExtendedBlockProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.ExtendedBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string poolId = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_poolid().data(),
        static_cast<int>(this->_internal_poolid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.ExtendedBlockProto.poolId");
    target =
        stream->WriteStringMaybeAliased(1, this->_internal_poolid(), target);
  }

  // required uint64 blockId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_blockid(), target);
  }

  // required uint64 generationStamp = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_generationstamp(), target);
  }

  // optional uint64 numBytes = 4 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            4, this->_internal_numbytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.ExtendedBlockProto)
  return target;
}

size_t ExtendedBlockProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.ExtendedBlockProto)
  size_t total_size = 0;

  if (_internal_has_poolid()) {
    // required string poolId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_poolid());
  }

  if (_internal_has_blockid()) {
    // required uint64 blockId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blockid());
  }

  if (_internal_has_generationstamp()) {
    // required uint64 generationStamp = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_generationstamp());
  }

  return total_size;
}
size_t ExtendedBlockProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.ExtendedBlockProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) ==
      0) {  // All required fields are present.
    // required string poolId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_poolid());

    // required uint64 blockId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blockid());

    // required uint64 generationStamp = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_generationstamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional uint64 numBytes = 4 [default = 0];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_numbytes());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtendedBlockProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.ExtendedBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  const ExtendedBlockProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExtendedBlockProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.ExtendedBlockProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.ExtendedBlockProto)
    MergeFrom(*source);
  }
}

void ExtendedBlockProto::MergeFrom(const ExtendedBlockProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.ExtendedBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      poolid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.poolid_);
    }
    if (cached_has_bits & 0x00000002u) {
      blockid_ = from.blockid_;
    }
    if (cached_has_bits & 0x00000004u) {
      generationstamp_ = from.generationstamp_;
    }
    if (cached_has_bits & 0x00000008u) {
      numbytes_ = from.numbytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ExtendedBlockProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.ExtendedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtendedBlockProto::CopyFrom(const ExtendedBlockProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.ExtendedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtendedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void ExtendedBlockProto::InternalSwap(ExtendedBlockProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  poolid_.Swap(
      &other->poolid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(blockid_, other->blockid_);
  swap(generationstamp_, other->generationstamp_);
  swap(numbytes_, other->numbytes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExtendedBlockProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void DatanodeIDProto::InitAsDefaultInstance() {}
class DatanodeIDProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DatanodeIDProto>()._has_bits_);
  static void set_has_ipaddr(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_hostname(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_datanodeuuid(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_xferport(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_infoport(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_ipcport(HasBits* has_bits) { (*has_bits)[0] |= 32u; }
  static void set_has_infosecureport(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

DatanodeIDProto::DatanodeIDProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.DatanodeIDProto)
}
DatanodeIDProto::DatanodeIDProto(const DatanodeIDProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ipaddr_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ipaddr()) {
    ipaddr_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.ipaddr_);
  }
  hostname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hostname()) {
    hostname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.hostname_);
  }
  datanodeuuid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_datanodeuuid()) {
    datanodeuuid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.datanodeuuid_);
  }
  ::memcpy(&xferport_, &from.xferport_,
           static_cast<size_t>(reinterpret_cast<char*>(&infosecureport_) -
                               reinterpret_cast<char*>(&xferport_)) +
               sizeof(infosecureport_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.DatanodeIDProto)
}

void DatanodeIDProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_DatanodeIDProto_hdfs_2eproto.base);
  ipaddr_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hostname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  datanodeuuid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&xferport_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&infosecureport_) -
                               reinterpret_cast<char*>(&xferport_)) +
               sizeof(infosecureport_));
}

DatanodeIDProto::~DatanodeIDProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.DatanodeIDProto)
  SharedDtor();
}

void DatanodeIDProto::SharedDtor() {
  ipaddr_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hostname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  datanodeuuid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DatanodeIDProto::SetCachedSize(int size) const { _cached_size_.Set(size); }
const DatanodeIDProto& DatanodeIDProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_DatanodeIDProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void DatanodeIDProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.DatanodeIDProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ipaddr_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      hostname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      datanodeuuid_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&xferport_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&infosecureport_) -
                                 reinterpret_cast<char*>(&xferport_)) +
                 sizeof(infosecureport_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DatanodeIDProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string ipAddr = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ipaddr();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DatanodeIDProto.ipAddr");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string hostName = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_hostname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DatanodeIDProto.hostName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string datanodeUuid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_datanodeuuid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DatanodeIDProto.datanodeUuid");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 xferPort = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_xferport(&has_bits);
          xferport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 infoPort = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_infoport(&has_bits);
          infoport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 ipcPort = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ipcport(&has_bits);
          ipcport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 infoSecurePort = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_infosecureport(&has_bits);
          infosecureport_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DatanodeIDProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.DatanodeIDProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ipAddr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_ipaddr().data(),
        static_cast<int>(this->_internal_ipaddr().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DatanodeIDProto.ipAddr");
    target =
        stream->WriteStringMaybeAliased(1, this->_internal_ipaddr(), target);
  }

  // required string hostName = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_hostname().data(),
        static_cast<int>(this->_internal_hostname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DatanodeIDProto.hostName");
    target =
        stream->WriteStringMaybeAliased(2, this->_internal_hostname(), target);
  }

  // required string datanodeUuid = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_datanodeuuid().data(),
        static_cast<int>(this->_internal_datanodeuuid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DatanodeIDProto.datanodeUuid");
    target = stream->WriteStringMaybeAliased(3, this->_internal_datanodeuuid(),
                                             target);
  }

  // required uint32 xferPort = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            4, this->_internal_xferport(), target);
  }

  // required uint32 infoPort = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            5, this->_internal_infoport(), target);
  }

  // required uint32 ipcPort = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            6, this->_internal_ipcport(), target);
  }

  // optional uint32 infoSecurePort = 7 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            7, this->_internal_infosecureport(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.DatanodeIDProto)
  return target;
}

size_t DatanodeIDProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.DatanodeIDProto)
  size_t total_size = 0;

  if (_internal_has_ipaddr()) {
    // required string ipAddr = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ipaddr());
  }

  if (_internal_has_hostname()) {
    // required string hostName = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_hostname());
  }

  if (_internal_has_datanodeuuid()) {
    // required string datanodeUuid = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_datanodeuuid());
  }

  if (_internal_has_xferport()) {
    // required uint32 xferPort = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_xferport());
  }

  if (_internal_has_infoport()) {
    // required uint32 infoPort = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_infoport());
  }

  if (_internal_has_ipcport()) {
    // required uint32 ipcPort = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_ipcport());
  }

  return total_size;
}
size_t DatanodeIDProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.DatanodeIDProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) ==
      0) {  // All required fields are present.
    // required string ipAddr = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ipaddr());

    // required string hostName = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_hostname());

    // required string datanodeUuid = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_datanodeuuid());

    // required uint32 xferPort = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_xferport());

    // required uint32 infoPort = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_infoport());

    // required uint32 ipcPort = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_ipcport());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional uint32 infoSecurePort = 7 [default = 0];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000040u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_infosecureport());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DatanodeIDProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.DatanodeIDProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DatanodeIDProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DatanodeIDProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.DatanodeIDProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.DatanodeIDProto)
    MergeFrom(*source);
  }
}

void DatanodeIDProto::MergeFrom(const DatanodeIDProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.DatanodeIDProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      ipaddr_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.ipaddr_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      hostname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.hostname_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      datanodeuuid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.datanodeuuid_);
    }
    if (cached_has_bits & 0x00000008u) {
      xferport_ = from.xferport_;
    }
    if (cached_has_bits & 0x00000010u) {
      infoport_ = from.infoport_;
    }
    if (cached_has_bits & 0x00000020u) {
      ipcport_ = from.ipcport_;
    }
    if (cached_has_bits & 0x00000040u) {
      infosecureport_ = from.infosecureport_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DatanodeIDProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.DatanodeIDProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeIDProto::CopyFrom(const DatanodeIDProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.DatanodeIDProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeIDProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void DatanodeIDProto::InternalSwap(DatanodeIDProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ipaddr_.Swap(
      &other->ipaddr_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  hostname_.Swap(
      &other->hostname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  datanodeuuid_.Swap(
      &other->datanodeuuid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(xferport_, other->xferport_);
  swap(infoport_, other->infoport_);
  swap(ipcport_, other->ipcport_);
  swap(infosecureport_, other->infosecureport_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DatanodeIDProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void DatanodeInfosProto::InitAsDefaultInstance() {}
class DatanodeInfosProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DatanodeInfosProto>()._has_bits_);
};

DatanodeInfosProto::DatanodeInfosProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.DatanodeInfosProto)
}
DatanodeInfosProto::DatanodeInfosProto(const DatanodeInfosProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      datanodes_(from.datanodes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.DatanodeInfosProto)
}

void DatanodeInfosProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_DatanodeInfosProto_hdfs_2eproto.base);
}

DatanodeInfosProto::~DatanodeInfosProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.DatanodeInfosProto)
  SharedDtor();
}

void DatanodeInfosProto::SharedDtor() {}

void DatanodeInfosProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DatanodeInfosProto& DatanodeInfosProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_DatanodeInfosProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void DatanodeInfosProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.DatanodeInfosProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  datanodes_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DatanodeInfosProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Hdfs.Internal.DatanodeInfoProto datanodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_datanodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DatanodeInfosProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.DatanodeInfosProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.DatanodeInfoProto datanodes = 1;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_datanodes_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, this->_internal_datanodes(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.DatanodeInfosProto)
  return target;
}

size_t DatanodeInfosProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.DatanodeInfosProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.DatanodeInfoProto datanodes = 1;
  total_size += 1UL * this->_internal_datanodes_size();
  for (const auto& msg : this->datanodes_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DatanodeInfosProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.DatanodeInfosProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DatanodeInfosProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DatanodeInfosProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.DatanodeInfosProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.DatanodeInfosProto)
    MergeFrom(*source);
  }
}

void DatanodeInfosProto::MergeFrom(const DatanodeInfosProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.DatanodeInfosProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  datanodes_.MergeFrom(from.datanodes_);
}

void DatanodeInfosProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.DatanodeInfosProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeInfosProto::CopyFrom(const DatanodeInfosProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.DatanodeInfosProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeInfosProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(datanodes_))
    return false;
  return true;
}

void DatanodeInfosProto::InternalSwap(DatanodeInfosProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  datanodes_.InternalSwap(&other->datanodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DatanodeInfosProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void DatanodeInfoProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_DatanodeInfoProto_default_instance_._instance
      .get_mutable()
      ->id_ = const_cast<::Hdfs::Internal::DatanodeIDProto*>(
      ::Hdfs::Internal::DatanodeIDProto::internal_default_instance());
}
class DatanodeInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DatanodeInfoProto>()._has_bits_);
  static const ::Hdfs::Internal::DatanodeIDProto& id(
      const DatanodeInfoProto* msg);
  static void set_has_id(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_capacity(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_dfsused(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_remaining(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_blockpoolused(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_lastupdate(HasBits* has_bits) { (*has_bits)[0] |= 64u; }
  static void set_has_xceivercount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_location(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_adminstate(HasBits* has_bits) { (*has_bits)[0] |= 256u; }
  static void set_has_cachecapacity(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cacheused(HasBits* has_bits) { (*has_bits)[0] |= 1024u; }
};

const ::Hdfs::Internal::DatanodeIDProto& DatanodeInfoProto::_Internal::id(
    const DatanodeInfoProto* msg) {
  return *msg->id_;
}
DatanodeInfoProto::DatanodeInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.DatanodeInfoProto)
}
DatanodeInfoProto::DatanodeInfoProto(const DatanodeInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  location_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_location()) {
    location_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.location_);
  }
  if (from._internal_has_id()) {
    id_ = new ::Hdfs::Internal::DatanodeIDProto(*from.id_);
  } else {
    id_ = nullptr;
  }
  ::memcpy(&capacity_, &from.capacity_,
           static_cast<size_t>(reinterpret_cast<char*>(&cacheused_) -
                               reinterpret_cast<char*>(&capacity_)) +
               sizeof(cacheused_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.DatanodeInfoProto)
}

void DatanodeInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_DatanodeInfoProto_hdfs_2eproto.base);
  location_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&id_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&cacheused_) -
                               reinterpret_cast<char*>(&id_)) +
               sizeof(cacheused_));
}

DatanodeInfoProto::~DatanodeInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.DatanodeInfoProto)
  SharedDtor();
}

void DatanodeInfoProto::SharedDtor() {
  location_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete id_;
}

void DatanodeInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DatanodeInfoProto& DatanodeInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_DatanodeInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void DatanodeInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.DatanodeInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      location_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(id_ != nullptr);
      id_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&capacity_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&xceivercount_) -
                                 reinterpret_cast<char*>(&capacity_)) +
                 sizeof(xceivercount_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&adminstate_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&cacheused_) -
                                 reinterpret_cast<char*>(&adminstate_)) +
                 sizeof(cacheused_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DatanodeInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.DatanodeIDProto id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 capacity = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_capacity(&has_bits);
          capacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 dfsUsed = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_dfsused(&has_bits);
          dfsused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 remaining = 4 [default = 0];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_remaining(&has_bits);
          remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blockPoolUsed = 5 [default = 0];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_blockpoolused(&has_bits);
          blockpoolused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 lastUpdate = 6 [default = 0];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_lastupdate(&has_bits);
          lastupdate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 xceiverCount = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_xceivercount(&has_bits);
          xceivercount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string location = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DatanodeInfoProto.location");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.DatanodeInfoProto.AdminState adminState = 10
      // [default = NORMAL];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::DatanodeInfoProto_AdminState_IsValid(
                      val))) {
            _internal_set_adminstate(
                static_cast<::Hdfs::Internal::DatanodeInfoProto_AdminState>(
                    val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cacheCapacity = 11 [default = 0];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_cachecapacity(&has_bits);
          cachecapacity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 cacheUsed = 12 [default = 0];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_cacheused(&has_bits);
          cacheused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DatanodeInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.DatanodeInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.DatanodeIDProto id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::id(this), target, stream);
  }

  // optional uint64 capacity = 2 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_capacity(), target);
  }

  // optional uint64 dfsUsed = 3 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_dfsused(), target);
  }

  // optional uint64 remaining = 4 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            4, this->_internal_remaining(), target);
  }

  // optional uint64 blockPoolUsed = 5 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            5, this->_internal_blockpoolused(), target);
  }

  // optional uint64 lastUpdate = 6 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            6, this->_internal_lastupdate(), target);
  }

  // optional uint32 xceiverCount = 7 [default = 0];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            7, this->_internal_xceivercount(), target);
  }

  // optional string location = 8;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_location().data(),
        static_cast<int>(this->_internal_location().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DatanodeInfoProto.location");
    target =
        stream->WriteStringMaybeAliased(8, this->_internal_location(), target);
  }

  // optional .Hdfs.Internal.DatanodeInfoProto.AdminState adminState = 10
  // [default = NORMAL];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            10, this->_internal_adminstate(), target);
  }

  // optional uint64 cacheCapacity = 11 [default = 0];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            11, this->_internal_cachecapacity(), target);
  }

  // optional uint64 cacheUsed = 12 [default = 0];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            12, this->_internal_cacheused(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.DatanodeInfoProto)
  return target;
}

size_t DatanodeInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.DatanodeInfoProto)
  size_t total_size = 0;

  // required .Hdfs.Internal.DatanodeIDProto id = 1;
  if (_internal_has_id()) {
    total_size +=
        1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*id_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional string location = 8;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_location());
  }

  if (cached_has_bits & 0x000000fcu) {
    // optional uint64 capacity = 2 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_capacity());
    }

    // optional uint64 dfsUsed = 3 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_dfsused());
    }

    // optional uint64 remaining = 4 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_remaining());
    }

    // optional uint64 blockPoolUsed = 5 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_blockpoolused());
    }

    // optional uint64 lastUpdate = 6 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_lastupdate());
    }

    // optional uint32 xceiverCount = 7 [default = 0];
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                  this->_internal_xceivercount());
    }
  }
  if (cached_has_bits & 0x00000700u) {
    // optional .Hdfs.Internal.DatanodeInfoProto.AdminState adminState = 10
    // [default = NORMAL];
    if (cached_has_bits & 0x00000100u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                  this->_internal_adminstate());
    }

    // optional uint64 cacheCapacity = 11 [default = 0];
    if (cached_has_bits & 0x00000200u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_cachecapacity());
    }

    // optional uint64 cacheUsed = 12 [default = 0];
    if (cached_has_bits & 0x00000400u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_cacheused());
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DatanodeInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.DatanodeInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DatanodeInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DatanodeInfoProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.DatanodeInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.DatanodeInfoProto)
    MergeFrom(*source);
  }
}

void DatanodeInfoProto::MergeFrom(const DatanodeInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.DatanodeInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      location_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.location_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_id()->::Hdfs::Internal::DatanodeIDProto::MergeFrom(
          from._internal_id());
    }
    if (cached_has_bits & 0x00000004u) {
      capacity_ = from.capacity_;
    }
    if (cached_has_bits & 0x00000008u) {
      dfsused_ = from.dfsused_;
    }
    if (cached_has_bits & 0x00000010u) {
      remaining_ = from.remaining_;
    }
    if (cached_has_bits & 0x00000020u) {
      blockpoolused_ = from.blockpoolused_;
    }
    if (cached_has_bits & 0x00000040u) {
      lastupdate_ = from.lastupdate_;
    }
    if (cached_has_bits & 0x00000080u) {
      xceivercount_ = from.xceivercount_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      adminstate_ = from.adminstate_;
    }
    if (cached_has_bits & 0x00000200u) {
      cachecapacity_ = from.cachecapacity_;
    }
    if (cached_has_bits & 0x00000400u) {
      cacheused_ = from.cacheused_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DatanodeInfoProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.DatanodeInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DatanodeInfoProto::CopyFrom(const DatanodeInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.DatanodeInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DatanodeInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (_internal_has_id()) {
    if (!id_->IsInitialized()) return false;
  }
  return true;
}

void DatanodeInfoProto::InternalSwap(DatanodeInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  location_.Swap(
      &other->location_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(id_, other->id_);
  swap(capacity_, other->capacity_);
  swap(dfsused_, other->dfsused_);
  swap(remaining_, other->remaining_);
  swap(blockpoolused_, other->blockpoolused_);
  swap(lastupdate_, other->lastupdate_);
  swap(xceivercount_, other->xceivercount_);
  swap(adminstate_, other->adminstate_);
  swap(cachecapacity_, other->cachecapacity_);
  swap(cacheused_, other->cacheused_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DatanodeInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void ContentSummaryProto::InitAsDefaultInstance() {}
class ContentSummaryProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ContentSummaryProto>()._has_bits_);
  static void set_has_length(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_filecount(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_directorycount(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_quota(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_spaceconsumed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_spacequota(HasBits* has_bits) { (*has_bits)[0] |= 32u; }
};

ContentSummaryProto::ContentSummaryProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.ContentSummaryProto)
}
ContentSummaryProto::ContentSummaryProto(const ContentSummaryProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&length_, &from.length_,
           static_cast<size_t>(reinterpret_cast<char*>(&spacequota_) -
                               reinterpret_cast<char*>(&length_)) +
               sizeof(spacequota_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.ContentSummaryProto)
}

void ContentSummaryProto::SharedCtor() {
  ::memset(&length_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&spacequota_) -
                               reinterpret_cast<char*>(&length_)) +
               sizeof(spacequota_));
}

ContentSummaryProto::~ContentSummaryProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.ContentSummaryProto)
  SharedDtor();
}

void ContentSummaryProto::SharedDtor() {}

void ContentSummaryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ContentSummaryProto& ContentSummaryProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_ContentSummaryProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void ContentSummaryProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.ContentSummaryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&length_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&spacequota_) -
                                 reinterpret_cast<char*>(&length_)) +
                 sizeof(spacequota_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ContentSummaryProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 fileCount = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_filecount(&has_bits);
          filecount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 directoryCount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_directorycount(&has_bits);
          directorycount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 quota = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_quota(&has_bits);
          quota_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 spaceConsumed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_spaceconsumed(&has_bits);
          spaceconsumed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 spaceQuota = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_spacequota(&has_bits);
          spacequota_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ContentSummaryProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.ContentSummaryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 length = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_length(), target);
  }

  // required uint64 fileCount = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_filecount(), target);
  }

  // required uint64 directoryCount = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_directorycount(), target);
  }

  // required uint64 quota = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            4, this->_internal_quota(), target);
  }

  // required uint64 spaceConsumed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            5, this->_internal_spaceconsumed(), target);
  }

  // required uint64 spaceQuota = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            6, this->_internal_spacequota(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.ContentSummaryProto)
  return target;
}

size_t ContentSummaryProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.ContentSummaryProto)
  size_t total_size = 0;

  if (_internal_has_length()) {
    // required uint64 length = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_length());
  }

  if (_internal_has_filecount()) {
    // required uint64 fileCount = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_filecount());
  }

  if (_internal_has_directorycount()) {
    // required uint64 directoryCount = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_directorycount());
  }

  if (_internal_has_quota()) {
    // required uint64 quota = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_quota());
  }

  if (_internal_has_spaceconsumed()) {
    // required uint64 spaceConsumed = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_spaceconsumed());
  }

  if (_internal_has_spacequota()) {
    // required uint64 spaceQuota = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_spacequota());
  }

  return total_size;
}
size_t ContentSummaryProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.ContentSummaryProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) ==
      0) {  // All required fields are present.
    // required uint64 length = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_length());

    // required uint64 fileCount = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_filecount());

    // required uint64 directoryCount = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_directorycount());

    // required uint64 quota = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_quota());

    // required uint64 spaceConsumed = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_spaceconsumed());

    // required uint64 spaceQuota = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_spacequota());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ContentSummaryProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.ContentSummaryProto)
  GOOGLE_DCHECK_NE(&from, this);
  const ContentSummaryProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ContentSummaryProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.ContentSummaryProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.ContentSummaryProto)
    MergeFrom(*source);
  }
}

void ContentSummaryProto::MergeFrom(const ContentSummaryProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.ContentSummaryProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      length_ = from.length_;
    }
    if (cached_has_bits & 0x00000002u) {
      filecount_ = from.filecount_;
    }
    if (cached_has_bits & 0x00000004u) {
      directorycount_ = from.directorycount_;
    }
    if (cached_has_bits & 0x00000008u) {
      quota_ = from.quota_;
    }
    if (cached_has_bits & 0x00000010u) {
      spaceconsumed_ = from.spaceconsumed_;
    }
    if (cached_has_bits & 0x00000020u) {
      spacequota_ = from.spacequota_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ContentSummaryProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.ContentSummaryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContentSummaryProto::CopyFrom(const ContentSummaryProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.ContentSummaryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContentSummaryProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void ContentSummaryProto::InternalSwap(ContentSummaryProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(length_, other->length_);
  swap(filecount_, other->filecount_);
  swap(directorycount_, other->directorycount_);
  swap(quota_, other->quota_);
  swap(spaceconsumed_, other->spaceconsumed_);
  swap(spacequota_, other->spacequota_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ContentSummaryProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void CorruptFileBlocksProto::InitAsDefaultInstance() {}
class CorruptFileBlocksProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CorruptFileBlocksProto>()._has_bits_);
  static void set_has_cookie(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

CorruptFileBlocksProto::CorruptFileBlocksProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.CorruptFileBlocksProto)
}
CorruptFileBlocksProto::CorruptFileBlocksProto(
    const CorruptFileBlocksProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      files_(from.files_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  cookie_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_cookie()) {
    cookie_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.cookie_);
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.CorruptFileBlocksProto)
}

void CorruptFileBlocksProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_CorruptFileBlocksProto_hdfs_2eproto.base);
  cookie_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

CorruptFileBlocksProto::~CorruptFileBlocksProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.CorruptFileBlocksProto)
  SharedDtor();
}

void CorruptFileBlocksProto::SharedDtor() {
  cookie_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CorruptFileBlocksProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CorruptFileBlocksProto& CorruptFileBlocksProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_CorruptFileBlocksProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void CorruptFileBlocksProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.CorruptFileBlocksProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  files_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    cookie_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CorruptFileBlocksProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string files = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_files();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
                str, ptr, ctx);
#ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
                str, "Hdfs.Internal.CorruptFileBlocksProto.files");
#endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required string cookie = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_cookie();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.CorruptFileBlocksProto.cookie");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CorruptFileBlocksProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.CorruptFileBlocksProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string files = 1;
  for (int i = 0, n = this->_internal_files_size(); i < n; i++) {
    const auto& s = this->_internal_files(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        s.data(), static_cast<int>(s.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.CorruptFileBlocksProto.files");
    target = stream->WriteString(1, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // required string cookie = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_cookie().data(),
        static_cast<int>(this->_internal_cookie().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.CorruptFileBlocksProto.cookie");
    target =
        stream->WriteStringMaybeAliased(2, this->_internal_cookie(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.CorruptFileBlocksProto)
  return target;
}

size_t CorruptFileBlocksProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.CorruptFileBlocksProto)
  size_t total_size = 0;

  // required string cookie = 2;
  if (_internal_has_cookie()) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_cookie());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated string files = 1;
  total_size +=
      1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(files_.size());
  for (int i = 0, n = files_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        files_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CorruptFileBlocksProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.CorruptFileBlocksProto)
  GOOGLE_DCHECK_NE(&from, this);
  const CorruptFileBlocksProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CorruptFileBlocksProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.CorruptFileBlocksProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.CorruptFileBlocksProto)
    MergeFrom(*source);
  }
}

void CorruptFileBlocksProto::MergeFrom(const CorruptFileBlocksProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.CorruptFileBlocksProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  files_.MergeFrom(from.files_);
  if (from._internal_has_cookie()) {
    _has_bits_[0] |= 0x00000001u;
    cookie_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.cookie_);
  }
}

void CorruptFileBlocksProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.CorruptFileBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CorruptFileBlocksProto::CopyFrom(const CorruptFileBlocksProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.CorruptFileBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CorruptFileBlocksProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void CorruptFileBlocksProto::InternalSwap(CorruptFileBlocksProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  files_.InternalSwap(&other->files_);
  cookie_.Swap(
      &other->cookie_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata CorruptFileBlocksProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void FsPermissionProto::InitAsDefaultInstance() {}
class FsPermissionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FsPermissionProto>()._has_bits_);
  static void set_has_perm(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

FsPermissionProto::FsPermissionProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.FsPermissionProto)
}
FsPermissionProto::FsPermissionProto(const FsPermissionProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  perm_ = from.perm_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.FsPermissionProto)
}

void FsPermissionProto::SharedCtor() { perm_ = 0u; }

FsPermissionProto::~FsPermissionProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.FsPermissionProto)
  SharedDtor();
}

void FsPermissionProto::SharedDtor() {}

void FsPermissionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FsPermissionProto& FsPermissionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_FsPermissionProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void FsPermissionProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.FsPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  perm_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FsPermissionProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 perm = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_perm(&has_bits);
          perm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FsPermissionProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.FsPermissionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 perm = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            1, this->_internal_perm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.FsPermissionProto)
  return target;
}

size_t FsPermissionProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.FsPermissionProto)
  size_t total_size = 0;

  // required uint32 perm = 1;
  if (_internal_has_perm()) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_perm());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FsPermissionProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.FsPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const FsPermissionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FsPermissionProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.FsPermissionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.FsPermissionProto)
    MergeFrom(*source);
  }
}

void FsPermissionProto::MergeFrom(const FsPermissionProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.FsPermissionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  if (from._internal_has_perm()) {
    _internal_set_perm(from._internal_perm());
  }
}

void FsPermissionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.FsPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FsPermissionProto::CopyFrom(const FsPermissionProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.FsPermissionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FsPermissionProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void FsPermissionProto::InternalSwap(FsPermissionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(perm_, other->perm_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FsPermissionProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void StorageUuidsProto::InitAsDefaultInstance() {}
class StorageUuidsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageUuidsProto>()._has_bits_);
};

StorageUuidsProto::StorageUuidsProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.StorageUuidsProto)
}
StorageUuidsProto::StorageUuidsProto(const StorageUuidsProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      storageuuids_(from.storageuuids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.StorageUuidsProto)
}

void StorageUuidsProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_StorageUuidsProto_hdfs_2eproto.base);
}

StorageUuidsProto::~StorageUuidsProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.StorageUuidsProto)
  SharedDtor();
}

void StorageUuidsProto::SharedDtor() {}

void StorageUuidsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StorageUuidsProto& StorageUuidsProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_StorageUuidsProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void StorageUuidsProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.StorageUuidsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  storageuuids_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StorageUuidsProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated string storageUuids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_storageuuids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
                str, ptr, ctx);
#ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
                str, "Hdfs.Internal.StorageUuidsProto.storageUuids");
#endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StorageUuidsProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.StorageUuidsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string storageUuids = 1;
  for (int i = 0, n = this->_internal_storageuuids_size(); i < n; i++) {
    const auto& s = this->_internal_storageuuids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        s.data(), static_cast<int>(s.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.StorageUuidsProto.storageUuids");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.StorageUuidsProto)
  return target;
}

size_t StorageUuidsProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.StorageUuidsProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated string storageUuids = 1;
  total_size +=
      1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(storageuuids_.size());
  for (int i = 0, n = storageuuids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        storageuuids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StorageUuidsProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.StorageUuidsProto)
  GOOGLE_DCHECK_NE(&from, this);
  const StorageUuidsProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StorageUuidsProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.StorageUuidsProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.StorageUuidsProto)
    MergeFrom(*source);
  }
}

void StorageUuidsProto::MergeFrom(const StorageUuidsProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.StorageUuidsProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  storageuuids_.MergeFrom(from.storageuuids_);
}

void StorageUuidsProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.StorageUuidsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageUuidsProto::CopyFrom(const StorageUuidsProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.StorageUuidsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageUuidsProto::IsInitialized() const { return true; }

void StorageUuidsProto::InternalSwap(StorageUuidsProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  storageuuids_.InternalSwap(&other->storageuuids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StorageUuidsProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void LocatedBlockProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_LocatedBlockProto_default_instance_._instance
      .get_mutable()
      ->b_ = const_cast<::Hdfs::Internal::ExtendedBlockProto*>(
      ::Hdfs::Internal::ExtendedBlockProto::internal_default_instance());
  ::Hdfs::Internal::_LocatedBlockProto_default_instance_._instance
      .get_mutable()
      ->blocktoken_ = const_cast<::Hdfs::Internal::TokenProto*>(
      ::Hdfs::Internal::TokenProto::internal_default_instance());
}
class LocatedBlockProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LocatedBlockProto>()._has_bits_);
  static const ::Hdfs::Internal::ExtendedBlockProto& b(
      const LocatedBlockProto* msg);
  static void set_has_b(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_offset(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_corrupt(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static const ::Hdfs::Internal::TokenProto& blocktoken(
      const LocatedBlockProto* msg);
  static void set_has_blocktoken(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
};

const ::Hdfs::Internal::ExtendedBlockProto& LocatedBlockProto::_Internal::b(
    const LocatedBlockProto* msg) {
  return *msg->b_;
}
const ::Hdfs::Internal::TokenProto& LocatedBlockProto::_Internal::blocktoken(
    const LocatedBlockProto* msg) {
  return *msg->blocktoken_;
}
void LocatedBlockProto::clear_blocktoken() {
  if (blocktoken_ != nullptr) blocktoken_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
LocatedBlockProto::LocatedBlockProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.LocatedBlockProto)
}
LocatedBlockProto::LocatedBlockProto(const LocatedBlockProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      locs_(from.locs_),
      iscached_(from.iscached_),
      storagetypes_(from.storagetypes_),
      storageids_(from.storageids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_b()) {
    b_ = new ::Hdfs::Internal::ExtendedBlockProto(*from.b_);
  } else {
    b_ = nullptr;
  }
  if (from._internal_has_blocktoken()) {
    blocktoken_ = new ::Hdfs::Internal::TokenProto(*from.blocktoken_);
  } else {
    blocktoken_ = nullptr;
  }
  ::memcpy(&offset_, &from.offset_,
           static_cast<size_t>(reinterpret_cast<char*>(&corrupt_) -
                               reinterpret_cast<char*>(&offset_)) +
               sizeof(corrupt_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.LocatedBlockProto)
}

void LocatedBlockProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_LocatedBlockProto_hdfs_2eproto.base);
  ::memset(&b_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&corrupt_) -
                               reinterpret_cast<char*>(&b_)) +
               sizeof(corrupt_));
}

LocatedBlockProto::~LocatedBlockProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.LocatedBlockProto)
  SharedDtor();
}

void LocatedBlockProto::SharedDtor() {
  if (this != internal_default_instance()) delete b_;
  if (this != internal_default_instance()) delete blocktoken_;
}

void LocatedBlockProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LocatedBlockProto& LocatedBlockProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_LocatedBlockProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void LocatedBlockProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.LocatedBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  locs_.Clear();
  iscached_.Clear();
  storagetypes_.Clear();
  storageids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(b_ != nullptr);
      b_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(blocktoken_ != nullptr);
      blocktoken_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&offset_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&corrupt_) -
                                 reinterpret_cast<char*>(&offset_)) +
                 sizeof(corrupt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* LocatedBlockProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.ExtendedBlockProto b = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_b(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Hdfs.Internal.DatanodeInfoProto locs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required bool corrupt = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_corrupt(&has_bits);
          corrupt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.TokenProto blockToken = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_blocktoken(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bool isCached = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedBoolParser(
              _internal_mutable_iscached(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48) {
          _internal_add_iscached(
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Hdfs.Internal.StorageTypeProto storageTypes = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val =
                ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(
                    ::Hdfs::Internal::StorageTypeProto_IsValid(val))) {
              _internal_add_storagetypes(
                  static_cast<::Hdfs::Internal::StorageTypeProto>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                  7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(
              _internal_mutable_storagetypes(), ptr, ctx,
              ::Hdfs::Internal::StorageTypeProto_IsValid, &_internal_metadata_,
              7);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string storageIDs = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_storageids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
                str, ptr, ctx);
#ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
                str, "Hdfs.Internal.LocatedBlockProto.storageIDs");
#endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LocatedBlockProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.LocatedBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.ExtendedBlockProto b = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::b(this), target, stream);
  }

  // required uint64 offset = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_offset(), target);
  }

  // repeated .Hdfs.Internal.DatanodeInfoProto locs = 3;
  for (unsigned int i = 0,
                    n = static_cast<unsigned int>(this->_internal_locs_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, this->_internal_locs(i), target, stream);
  }

  // required bool corrupt = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            4, this->_internal_corrupt(), target);
  }

  // required .Hdfs.Internal.TokenProto blockToken = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::blocktoken(this), target, stream);
  }

  // repeated bool isCached = 6 [packed = true];
  if (this->_internal_iscached_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_iscached(), target);
  }

  // repeated .Hdfs.Internal.StorageTypeProto storageTypes = 7;
  for (int i = 0, n = this->_internal_storagetypes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            7, this->_internal_storagetypes(i), target);
  }

  // repeated string storageIDs = 8;
  for (int i = 0, n = this->_internal_storageids_size(); i < n; i++) {
    const auto& s = this->_internal_storageids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        s.data(), static_cast<int>(s.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.LocatedBlockProto.storageIDs");
    target = stream->WriteString(8, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.LocatedBlockProto)
  return target;
}

size_t LocatedBlockProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.LocatedBlockProto)
  size_t total_size = 0;

  if (_internal_has_b()) {
    // required .Hdfs.Internal.ExtendedBlockProto b = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*b_);
  }

  if (_internal_has_blocktoken()) {
    // required .Hdfs.Internal.TokenProto blockToken = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *blocktoken_);
  }

  if (_internal_has_offset()) {
    // required uint64 offset = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_offset());
  }

  if (_internal_has_corrupt()) {
    // required bool corrupt = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t LocatedBlockProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.LocatedBlockProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) ==
      0) {  // All required fields are present.
    // required .Hdfs.Internal.ExtendedBlockProto b = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*b_);

    // required .Hdfs.Internal.TokenProto blockToken = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *blocktoken_);

    // required uint64 offset = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_offset());

    // required bool corrupt = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.DatanodeInfoProto locs = 3;
  total_size += 1UL * this->_internal_locs_size();
  for (const auto& msg : this->locs_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bool isCached = 6 [packed = true];
  {
    unsigned int count =
        static_cast<unsigned int>(this->_internal_iscached_size());
    size_t data_size = 1UL * count;
    if (data_size > 0) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                  static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size =
        ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _iscached_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .Hdfs.Internal.StorageTypeProto storageTypes = 7;
  {
    size_t data_size = 0;
    unsigned int count =
        static_cast<unsigned int>(this->_internal_storagetypes_size());
    for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
          this->_internal_storagetypes(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated string storageIDs = 8;
  total_size +=
      1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(storageids_.size());
  for (int i = 0, n = storageids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        storageids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocatedBlockProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.LocatedBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  const LocatedBlockProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LocatedBlockProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.LocatedBlockProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.LocatedBlockProto)
    MergeFrom(*source);
  }
}

void LocatedBlockProto::MergeFrom(const LocatedBlockProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.LocatedBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  locs_.MergeFrom(from.locs_);
  iscached_.MergeFrom(from.iscached_);
  storagetypes_.MergeFrom(from.storagetypes_);
  storageids_.MergeFrom(from.storageids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_b()->::Hdfs::Internal::ExtendedBlockProto::MergeFrom(
          from._internal_b());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_blocktoken()->::Hdfs::Internal::TokenProto::MergeFrom(
          from._internal_blocktoken());
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      corrupt_ = from.corrupt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LocatedBlockProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.LocatedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlockProto::CopyFrom(const LocatedBlockProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.LocatedBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(locs_))
    return false;
  if (_internal_has_b()) {
    if (!b_->IsInitialized()) return false;
  }
  if (_internal_has_blocktoken()) {
    if (!blocktoken_->IsInitialized()) return false;
  }
  return true;
}

void LocatedBlockProto::InternalSwap(LocatedBlockProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  locs_.InternalSwap(&other->locs_);
  iscached_.InternalSwap(&other->iscached_);
  storagetypes_.InternalSwap(&other->storagetypes_);
  storageids_.InternalSwap(&other->storageids_);
  swap(b_, other->b_);
  swap(blocktoken_, other->blocktoken_);
  swap(offset_, other->offset_);
  swap(corrupt_, other->corrupt_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LocatedBlockProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void DataEncryptionKeyProto::InitAsDefaultInstance() {}
class DataEncryptionKeyProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DataEncryptionKeyProto>()._has_bits_);
  static void set_has_keyid(HasBits* has_bits) { (*has_bits)[0] |= 32u; }
  static void set_has_blockpoolid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_nonce(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_encryptionkey(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_expirydate(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_encryptionalgorithm(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

DataEncryptionKeyProto::DataEncryptionKeyProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.DataEncryptionKeyProto)
}
DataEncryptionKeyProto::DataEncryptionKeyProto(
    const DataEncryptionKeyProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blockpoolid()) {
    blockpoolid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.blockpoolid_);
  }
  nonce_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nonce()) {
    nonce_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.nonce_);
  }
  encryptionkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encryptionkey()) {
    encryptionkey_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.encryptionkey_);
  }
  encryptionalgorithm_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_encryptionalgorithm()) {
    encryptionalgorithm_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.encryptionalgorithm_);
  }
  ::memcpy(&expirydate_, &from.expirydate_,
           static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                               reinterpret_cast<char*>(&expirydate_)) +
               sizeof(keyid_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.DataEncryptionKeyProto)
}

void DataEncryptionKeyProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_DataEncryptionKeyProto_hdfs_2eproto.base);
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nonce_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryptionkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryptionalgorithm_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&expirydate_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                               reinterpret_cast<char*>(&expirydate_)) +
               sizeof(keyid_));
}

DataEncryptionKeyProto::~DataEncryptionKeyProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.DataEncryptionKeyProto)
  SharedDtor();
}

void DataEncryptionKeyProto::SharedDtor() {
  blockpoolid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nonce_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryptionkey_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encryptionalgorithm_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DataEncryptionKeyProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DataEncryptionKeyProto& DataEncryptionKeyProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_DataEncryptionKeyProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void DataEncryptionKeyProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.DataEncryptionKeyProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      blockpoolid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      nonce_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      encryptionkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      encryptionalgorithm_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&expirydate_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                                 reinterpret_cast<char*>(&expirydate_)) +
                 sizeof(keyid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DataEncryptionKeyProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 keyId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_keyid(&has_bits);
          keyid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string blockPoolId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_blockpoolid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DataEncryptionKeyProto.blockPoolId");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes nonce = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_nonce();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes encryptionKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_encryptionkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 expiryDate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_expirydate(&has_bits);
          expirydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string encryptionAlgorithm = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_encryptionalgorithm();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DataEncryptionKeyProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.DataEncryptionKeyProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 keyId = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            1, this->_internal_keyid(), target);
  }

  // required string blockPoolId = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_blockpoolid().data(),
        static_cast<int>(this->_internal_blockpoolid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DataEncryptionKeyProto.blockPoolId");
    target = stream->WriteStringMaybeAliased(2, this->_internal_blockpoolid(),
                                             target);
  }

  // required bytes nonce = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(3, this->_internal_nonce(), target);
  }

  // required bytes encryptionKey = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(4, this->_internal_encryptionkey(),
                                            target);
  }

  // required uint64 expiryDate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            5, this->_internal_expirydate(), target);
  }

  // optional string encryptionAlgorithm = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_encryptionalgorithm().data(),
        static_cast<int>(this->_internal_encryptionalgorithm().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.DataEncryptionKeyProto.encryptionAlgorithm");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_encryptionalgorithm(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.DataEncryptionKeyProto)
  return target;
}

size_t DataEncryptionKeyProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.DataEncryptionKeyProto)
  size_t total_size = 0;

  if (_internal_has_blockpoolid()) {
    // required string blockPoolId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());
  }

  if (_internal_has_nonce()) {
    // required bytes nonce = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_nonce());
  }

  if (_internal_has_encryptionkey()) {
    // required bytes encryptionKey = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_encryptionkey());
  }

  if (_internal_has_expirydate()) {
    // required uint64 expiryDate = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_expirydate());
  }

  if (_internal_has_keyid()) {
    // required uint32 keyId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_keyid());
  }

  return total_size;
}
size_t DataEncryptionKeyProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.DataEncryptionKeyProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000037) ^ 0x00000037) ==
      0) {  // All required fields are present.
    // required string blockPoolId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());

    // required bytes nonce = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_nonce());

    // required bytes encryptionKey = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_encryptionkey());

    // required uint64 expiryDate = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_expirydate());

    // required uint32 keyId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_keyid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional string encryptionAlgorithm = 6;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_encryptionalgorithm());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DataEncryptionKeyProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.DataEncryptionKeyProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DataEncryptionKeyProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DataEncryptionKeyProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.DataEncryptionKeyProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.DataEncryptionKeyProto)
    MergeFrom(*source);
  }
}

void DataEncryptionKeyProto::MergeFrom(const DataEncryptionKeyProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.DataEncryptionKeyProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      blockpoolid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.blockpoolid_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      nonce_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.nonce_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      encryptionkey_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.encryptionkey_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      encryptionalgorithm_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.encryptionalgorithm_);
    }
    if (cached_has_bits & 0x00000010u) {
      expirydate_ = from.expirydate_;
    }
    if (cached_has_bits & 0x00000020u) {
      keyid_ = from.keyid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void DataEncryptionKeyProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.DataEncryptionKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataEncryptionKeyProto::CopyFrom(const DataEncryptionKeyProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.DataEncryptionKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataEncryptionKeyProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;
  return true;
}

void DataEncryptionKeyProto::InternalSwap(DataEncryptionKeyProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blockpoolid_.Swap(
      &other->blockpoolid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  nonce_.Swap(&other->nonce_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  encryptionkey_.Swap(
      &other->encryptionkey_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  encryptionalgorithm_.Swap(
      &other->encryptionalgorithm_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(expirydate_, other->expirydate_);
  swap(keyid_, other->keyid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DataEncryptionKeyProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void FileEncryptionInfoProto::InitAsDefaultInstance() {}
class FileEncryptionInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FileEncryptionInfoProto>()._has_bits_);
  static void set_has_suite(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_cryptoprotocolversion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_key(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_iv(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_keyname(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_ezkeyversionname(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

FileEncryptionInfoProto::FileEncryptionInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.FileEncryptionInfoProto)
}
FileEncryptionInfoProto::FileEncryptionInfoProto(
    const FileEncryptionInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.key_);
  }
  iv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_iv()) {
    iv_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.iv_);
  }
  keyname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_keyname()) {
    keyname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.keyname_);
  }
  ezkeyversionname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ezkeyversionname()) {
    ezkeyversionname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.ezkeyversionname_);
  }
  ::memcpy(
      &suite_, &from.suite_,
      static_cast<size_t>(reinterpret_cast<char*>(&cryptoprotocolversion_) -
                          reinterpret_cast<char*>(&suite_)) +
          sizeof(cryptoprotocolversion_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.FileEncryptionInfoProto)
}

void FileEncryptionInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_FileEncryptionInfoProto_hdfs_2eproto.base);
  key_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suite_ = 1;
  cryptoprotocolversion_ = 1;
}

FileEncryptionInfoProto::~FileEncryptionInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.FileEncryptionInfoProto)
  SharedDtor();
}

void FileEncryptionInfoProto::SharedDtor() {
  key_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void FileEncryptionInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FileEncryptionInfoProto& FileEncryptionInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_FileEncryptionInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void FileEncryptionInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.FileEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      iv_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      keyname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      ezkeyversionname_.ClearNonDefaultToEmptyNoArena();
    }
    suite_ = 1;
    cryptoprotocolversion_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FileEncryptionInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.CipherSuiteProto suite = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::CipherSuiteProto_IsValid(val))) {
            _internal_set_suite(
                static_cast<::Hdfs::Internal::CipherSuiteProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.CryptoProtocolVersionProto
      // cryptoProtocolVersion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::CryptoProtocolVersionProto_IsValid(val))) {
            _internal_set_cryptoprotocolversion(
                static_cast<::Hdfs::Internal::CryptoProtocolVersionProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes iv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_iv();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string keyName = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_keyname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.FileEncryptionInfoProto.keyName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ezKeyVersionName = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_ezkeyversionname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FileEncryptionInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.FileEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            1, this->_internal_suite(), target);
  }

  // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion =
  // 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            2, this->_internal_cryptoprotocolversion(), target);
  }

  // required bytes key = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(3, this->_internal_key(), target);
  }

  // required bytes iv = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(4, this->_internal_iv(), target);
  }

  // required string keyName = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_keyname().data(),
        static_cast<int>(this->_internal_keyname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.FileEncryptionInfoProto.keyName");
    target =
        stream->WriteStringMaybeAliased(5, this->_internal_keyname(), target);
  }

  // required string ezKeyVersionName = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_ezkeyversionname().data(),
        static_cast<int>(this->_internal_ezkeyversionname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.FileEncryptionInfoProto.ezKeyVersionName");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_ezkeyversionname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.FileEncryptionInfoProto)
  return target;
}

size_t FileEncryptionInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.FileEncryptionInfoProto)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_key());
  }

  if (_internal_has_iv()) {
    // required bytes iv = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_iv());
  }

  if (_internal_has_keyname()) {
    // required string keyName = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_keyname());
  }

  if (_internal_has_ezkeyversionname()) {
    // required string ezKeyVersionName = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ezkeyversionname());
  }

  if (_internal_has_suite()) {
    // required .Hdfs.Internal.CipherSuiteProto suite = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_suite());
  }

  if (_internal_has_cryptoprotocolversion()) {
    // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion
    // = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_cryptoprotocolversion());
  }

  return total_size;
}
size_t FileEncryptionInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.FileEncryptionInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) ==
      0) {  // All required fields are present.
    // required bytes key = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_key());

    // required bytes iv = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_iv());

    // required string keyName = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_keyname());

    // required string ezKeyVersionName = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ezkeyversionname());

    // required .Hdfs.Internal.CipherSuiteProto suite = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_suite());

    // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion
    // = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_cryptoprotocolversion());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FileEncryptionInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.FileEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const FileEncryptionInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FileEncryptionInfoProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.FileEncryptionInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.FileEncryptionInfoProto)
    MergeFrom(*source);
  }
}

void FileEncryptionInfoProto::MergeFrom(const FileEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.FileEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      iv_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.iv_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      keyname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.keyname_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      ezkeyversionname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.ezkeyversionname_);
    }
    if (cached_has_bits & 0x00000010u) {
      suite_ = from.suite_;
    }
    if (cached_has_bits & 0x00000020u) {
      cryptoprotocolversion_ = from.cryptoprotocolversion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FileEncryptionInfoProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.FileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileEncryptionInfoProto::CopyFrom(const FileEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.FileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileEncryptionInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void FileEncryptionInfoProto::InternalSwap(FileEncryptionInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_,
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
            GetArenaNoVirtual());
  iv_.Swap(&other->iv_,
           &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
           GetArenaNoVirtual());
  keyname_.Swap(
      &other->keyname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  ezkeyversionname_.Swap(
      &other->ezkeyversionname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(suite_, other->suite_);
  swap(cryptoprotocolversion_, other->cryptoprotocolversion_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FileEncryptionInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void PerFileEncryptionInfoProto::InitAsDefaultInstance() {}
class PerFileEncryptionInfoProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<PerFileEncryptionInfoProto>()._has_bits_);
  static void set_has_key(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_iv(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_ezkeyversionname(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

PerFileEncryptionInfoProto::PerFileEncryptionInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.PerFileEncryptionInfoProto)
}
PerFileEncryptionInfoProto::PerFileEncryptionInfoProto(
    const PerFileEncryptionInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  key_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.key_);
  }
  iv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_iv()) {
    iv_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.iv_);
  }
  ezkeyversionname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ezkeyversionname()) {
    ezkeyversionname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.ezkeyversionname_);
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.PerFileEncryptionInfoProto)
}

void PerFileEncryptionInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_PerFileEncryptionInfoProto_hdfs_2eproto.base);
  key_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

PerFileEncryptionInfoProto::~PerFileEncryptionInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.PerFileEncryptionInfoProto)
  SharedDtor();
}

void PerFileEncryptionInfoProto::SharedDtor() {
  key_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ezkeyversionname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PerFileEncryptionInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PerFileEncryptionInfoProto&
PerFileEncryptionInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_PerFileEncryptionInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void PerFileEncryptionInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      iv_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      ezkeyversionname_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PerFileEncryptionInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes iv = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_iv();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string ezKeyVersionName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_ezkeyversionname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PerFileEncryptionInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(1, this->_internal_key(), target);
  }

  // required bytes iv = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(2, this->_internal_iv(), target);
  }

  // required string ezKeyVersionName = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_ezkeyversionname().data(),
        static_cast<int>(this->_internal_ezkeyversionname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.PerFileEncryptionInfoProto.ezKeyVersionName");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ezkeyversionname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.PerFileEncryptionInfoProto)
  return target;
}

size_t PerFileEncryptionInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_key());
  }

  if (_internal_has_iv()) {
    // required bytes iv = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_iv());
  }

  if (_internal_has_ezkeyversionname()) {
    // required string ezKeyVersionName = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ezkeyversionname());
  }

  return total_size;
}
size_t PerFileEncryptionInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) ==
      0) {  // All required fields are present.
    // required bytes key = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_key());

    // required bytes iv = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_iv());

    // required string ezKeyVersionName = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_ezkeyversionname());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PerFileEncryptionInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const PerFileEncryptionInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          PerFileEncryptionInfoProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.PerFileEncryptionInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.PerFileEncryptionInfoProto)
    MergeFrom(*source);
  }
}

void PerFileEncryptionInfoProto::MergeFrom(
    const PerFileEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      key_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.key_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      iv_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.iv_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      ezkeyversionname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.ezkeyversionname_);
    }
  }
}

void PerFileEncryptionInfoProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PerFileEncryptionInfoProto::CopyFrom(
    const PerFileEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.PerFileEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerFileEncryptionInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void PerFileEncryptionInfoProto::InternalSwap(
    PerFileEncryptionInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_,
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
            GetArenaNoVirtual());
  iv_.Swap(&other->iv_,
           &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
           GetArenaNoVirtual());
  ezkeyversionname_.Swap(
      &other->ezkeyversionname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata PerFileEncryptionInfoProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void ZoneEncryptionInfoProto::InitAsDefaultInstance() {}
class ZoneEncryptionInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ZoneEncryptionInfoProto>()._has_bits_);
  static void set_has_suite(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_cryptoprotocolversion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_keyname(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

ZoneEncryptionInfoProto::ZoneEncryptionInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.ZoneEncryptionInfoProto)
}
ZoneEncryptionInfoProto::ZoneEncryptionInfoProto(
    const ZoneEncryptionInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  keyname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_keyname()) {
    keyname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.keyname_);
  }
  ::memcpy(
      &suite_, &from.suite_,
      static_cast<size_t>(reinterpret_cast<char*>(&cryptoprotocolversion_) -
                          reinterpret_cast<char*>(&suite_)) +
          sizeof(cryptoprotocolversion_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.ZoneEncryptionInfoProto)
}

void ZoneEncryptionInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_ZoneEncryptionInfoProto_hdfs_2eproto.base);
  keyname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suite_ = 1;
  cryptoprotocolversion_ = 1;
}

ZoneEncryptionInfoProto::~ZoneEncryptionInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.ZoneEncryptionInfoProto)
  SharedDtor();
}

void ZoneEncryptionInfoProto::SharedDtor() {
  keyname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ZoneEncryptionInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ZoneEncryptionInfoProto& ZoneEncryptionInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_ZoneEncryptionInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void ZoneEncryptionInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      keyname_.ClearNonDefaultToEmptyNoArena();
    }
    suite_ = 1;
    cryptoprotocolversion_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ZoneEncryptionInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.CipherSuiteProto suite = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::CipherSuiteProto_IsValid(val))) {
            _internal_set_suite(
                static_cast<::Hdfs::Internal::CipherSuiteProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.CryptoProtocolVersionProto
      // cryptoProtocolVersion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::CryptoProtocolVersionProto_IsValid(val))) {
            _internal_set_cryptoprotocolversion(
                static_cast<::Hdfs::Internal::CryptoProtocolVersionProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required string keyName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_keyname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.ZoneEncryptionInfoProto.keyName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ZoneEncryptionInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            1, this->_internal_suite(), target);
  }

  // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion =
  // 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            2, this->_internal_cryptoprotocolversion(), target);
  }

  // required string keyName = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_keyname().data(),
        static_cast<int>(this->_internal_keyname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.ZoneEncryptionInfoProto.keyName");
    target =
        stream->WriteStringMaybeAliased(3, this->_internal_keyname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.ZoneEncryptionInfoProto)
  return target;
}

size_t ZoneEncryptionInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  size_t total_size = 0;

  if (_internal_has_keyname()) {
    // required string keyName = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_keyname());
  }

  if (_internal_has_suite()) {
    // required .Hdfs.Internal.CipherSuiteProto suite = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_suite());
  }

  if (_internal_has_cryptoprotocolversion()) {
    // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion
    // = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_cryptoprotocolversion());
  }

  return total_size;
}
size_t ZoneEncryptionInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) ==
      0) {  // All required fields are present.
    // required string keyName = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_keyname());

    // required .Hdfs.Internal.CipherSuiteProto suite = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_suite());

    // required .Hdfs.Internal.CryptoProtocolVersionProto cryptoProtocolVersion
    // = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_cryptoprotocolversion());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ZoneEncryptionInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const ZoneEncryptionInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ZoneEncryptionInfoProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.ZoneEncryptionInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.ZoneEncryptionInfoProto)
    MergeFrom(*source);
  }
}

void ZoneEncryptionInfoProto::MergeFrom(const ZoneEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      keyname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.keyname_);
    }
    if (cached_has_bits & 0x00000002u) {
      suite_ = from.suite_;
    }
    if (cached_has_bits & 0x00000004u) {
      cryptoprotocolversion_ = from.cryptoprotocolversion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ZoneEncryptionInfoProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ZoneEncryptionInfoProto::CopyFrom(const ZoneEncryptionInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.ZoneEncryptionInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ZoneEncryptionInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void ZoneEncryptionInfoProto::InternalSwap(ZoneEncryptionInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  keyname_.Swap(
      &other->keyname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(suite_, other->suite_);
  swap(cryptoprotocolversion_, other->cryptoprotocolversion_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ZoneEncryptionInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void CipherOptionProto::InitAsDefaultInstance() {}
class CipherOptionProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CipherOptionProto>()._has_bits_);
  static void set_has_suite(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_inkey(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_iniv(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_outkey(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_outiv(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
};

CipherOptionProto::CipherOptionProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.CipherOptionProto)
}
CipherOptionProto::CipherOptionProto(const CipherOptionProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  inkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_inkey()) {
    inkey_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.inkey_);
  }
  iniv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_iniv()) {
    iniv_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.iniv_);
  }
  outkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_outkey()) {
    outkey_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.outkey_);
  }
  outiv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_outiv()) {
    outiv_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.outiv_);
  }
  suite_ = from.suite_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.CipherOptionProto)
}

void CipherOptionProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_CipherOptionProto_hdfs_2eproto.base);
  inkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iniv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outkey_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outiv_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  suite_ = 1;
}

CipherOptionProto::~CipherOptionProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.CipherOptionProto)
  SharedDtor();
}

void CipherOptionProto::SharedDtor() {
  inkey_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  iniv_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outkey_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  outiv_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CipherOptionProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CipherOptionProto& CipherOptionProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_CipherOptionProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void CipherOptionProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.CipherOptionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      inkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      iniv_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      outkey_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      outiv_.ClearNonDefaultToEmptyNoArena();
    }
    suite_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CipherOptionProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.CipherSuiteProto suite = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::CipherSuiteProto_IsValid(val))) {
            _internal_set_suite(
                static_cast<::Hdfs::Internal::CipherSuiteProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes inKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_inkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes inIv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_iniv();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes outKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_outkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes outIv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_outiv();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CipherOptionProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.CipherOptionProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            1, this->_internal_suite(), target);
  }

  // optional bytes inKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(2, this->_internal_inkey(), target);
  }

  // optional bytes inIv = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(3, this->_internal_iniv(), target);
  }

  // optional bytes outKey = 4;
  if (cached_has_bits & 0x00000004u) {
    target =
        stream->WriteBytesMaybeAliased(4, this->_internal_outkey(), target);
  }

  // optional bytes outIv = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(5, this->_internal_outiv(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.CipherOptionProto)
  return target;
}

size_t CipherOptionProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.CipherOptionProto)
  size_t total_size = 0;

  // required .Hdfs.Internal.CipherSuiteProto suite = 1;
  if (_internal_has_suite()) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_suite());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes inKey = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                  this->_internal_inkey());
    }

    // optional bytes inIv = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                  this->_internal_iniv());
    }

    // optional bytes outKey = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                  this->_internal_outkey());
    }

    // optional bytes outIv = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                  this->_internal_outiv());
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CipherOptionProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.CipherOptionProto)
  GOOGLE_DCHECK_NE(&from, this);
  const CipherOptionProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CipherOptionProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.CipherOptionProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.CipherOptionProto)
    MergeFrom(*source);
  }
}

void CipherOptionProto::MergeFrom(const CipherOptionProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.CipherOptionProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      inkey_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.inkey_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      iniv_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.iniv_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      outkey_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.outkey_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      outiv_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.outiv_);
    }
    if (cached_has_bits & 0x00000010u) {
      suite_ = from.suite_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CipherOptionProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.CipherOptionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CipherOptionProto::CopyFrom(const CipherOptionProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.CipherOptionProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CipherOptionProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000010) != 0x00000010) return false;
  return true;
}

void CipherOptionProto::InternalSwap(CipherOptionProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  inkey_.Swap(&other->inkey_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  iniv_.Swap(&other->iniv_,
             &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
             GetArenaNoVirtual());
  outkey_.Swap(
      &other->outkey_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  outiv_.Swap(&other->outiv_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  swap(suite_, other->suite_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CipherOptionProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void LocatedBlocksProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_LocatedBlocksProto_default_instance_._instance
      .get_mutable()
      ->lastblock_ = const_cast<::Hdfs::Internal::LocatedBlockProto*>(
      ::Hdfs::Internal::LocatedBlockProto::internal_default_instance());
}
class LocatedBlocksProto::_Internal {
 public:
  using HasBits = decltype(std::declval<LocatedBlocksProto>()._has_bits_);
  static void set_has_filelength(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_underconstruction(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::Hdfs::Internal::LocatedBlockProto& lastblock(
      const LocatedBlocksProto* msg);
  static void set_has_lastblock(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_islastblockcomplete(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::Hdfs::Internal::LocatedBlockProto&
LocatedBlocksProto::_Internal::lastblock(const LocatedBlocksProto* msg) {
  return *msg->lastblock_;
}
LocatedBlocksProto::LocatedBlocksProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.LocatedBlocksProto)
}
LocatedBlocksProto::LocatedBlocksProto(const LocatedBlocksProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      blocks_(from.blocks_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_lastblock()) {
    lastblock_ = new ::Hdfs::Internal::LocatedBlockProto(*from.lastblock_);
  } else {
    lastblock_ = nullptr;
  }
  ::memcpy(&filelength_, &from.filelength_,
           static_cast<size_t>(reinterpret_cast<char*>(&islastblockcomplete_) -
                               reinterpret_cast<char*>(&filelength_)) +
               sizeof(islastblockcomplete_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.LocatedBlocksProto)
}

void LocatedBlocksProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_LocatedBlocksProto_hdfs_2eproto.base);
  ::memset(&lastblock_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&islastblockcomplete_) -
                               reinterpret_cast<char*>(&lastblock_)) +
               sizeof(islastblockcomplete_));
}

LocatedBlocksProto::~LocatedBlocksProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.LocatedBlocksProto)
  SharedDtor();
}

void LocatedBlocksProto::SharedDtor() {
  if (this != internal_default_instance()) delete lastblock_;
}

void LocatedBlocksProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LocatedBlocksProto& LocatedBlocksProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_LocatedBlocksProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void LocatedBlocksProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.LocatedBlocksProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  blocks_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(lastblock_ != nullptr);
    lastblock_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(
        &filelength_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&islastblockcomplete_) -
                            reinterpret_cast<char*>(&filelength_)) +
            sizeof(islastblockcomplete_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* LocatedBlocksProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 fileLength = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_filelength(&has_bits);
          filelength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Hdfs.Internal.LocatedBlockProto blocks = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required bool underConstruction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_underconstruction(&has_bits);
          underconstruction_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.LocatedBlockProto lastBlock = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_lastblock(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool isLastBlockComplete = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_islastblockcomplete(&has_bits);
          islastblockcomplete_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LocatedBlocksProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.LocatedBlocksProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 fileLength = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_filelength(), target);
  }

  // repeated .Hdfs.Internal.LocatedBlockProto blocks = 2;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_blocks_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, this->_internal_blocks(i), target, stream);
  }

  // required bool underConstruction = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            3, this->_internal_underconstruction(), target);
  }

  // optional .Hdfs.Internal.LocatedBlockProto lastBlock = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::lastblock(this), target, stream);
  }

  // required bool isLastBlockComplete = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            5, this->_internal_islastblockcomplete(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.LocatedBlocksProto)
  return target;
}

size_t LocatedBlocksProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.LocatedBlocksProto)
  size_t total_size = 0;

  if (_internal_has_filelength()) {
    // required uint64 fileLength = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_filelength());
  }

  if (_internal_has_underconstruction()) {
    // required bool underConstruction = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_islastblockcomplete()) {
    // required bool isLastBlockComplete = 5;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t LocatedBlocksProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.LocatedBlocksProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) ==
      0) {  // All required fields are present.
    // required uint64 fileLength = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_filelength());

    // required bool underConstruction = 3;
    total_size += 1 + 1;

    // required bool isLastBlockComplete = 5;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.LocatedBlockProto blocks = 2;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->blocks_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .Hdfs.Internal.LocatedBlockProto lastBlock = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *lastblock_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LocatedBlocksProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.LocatedBlocksProto)
  GOOGLE_DCHECK_NE(&from, this);
  const LocatedBlocksProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LocatedBlocksProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.LocatedBlocksProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.LocatedBlocksProto)
    MergeFrom(*source);
  }
}

void LocatedBlocksProto::MergeFrom(const LocatedBlocksProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.LocatedBlocksProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  blocks_.MergeFrom(from.blocks_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_lastblock()
          ->::Hdfs::Internal::LocatedBlockProto::MergeFrom(
              from._internal_lastblock());
    }
    if (cached_has_bits & 0x00000002u) {
      filelength_ = from.filelength_;
    }
    if (cached_has_bits & 0x00000004u) {
      underconstruction_ = from.underconstruction_;
    }
    if (cached_has_bits & 0x00000008u) {
      islastblockcomplete_ = from.islastblockcomplete_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LocatedBlocksProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.LocatedBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LocatedBlocksProto::CopyFrom(const LocatedBlocksProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.LocatedBlocksProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LocatedBlocksProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000e) != 0x0000000e) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(blocks_))
    return false;
  if (_internal_has_lastblock()) {
    if (!lastblock_->IsInitialized()) return false;
  }
  return true;
}

void LocatedBlocksProto::InternalSwap(LocatedBlocksProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blocks_.InternalSwap(&other->blocks_);
  swap(lastblock_, other->lastblock_);
  swap(filelength_, other->filelength_);
  swap(underconstruction_, other->underconstruction_);
  swap(islastblockcomplete_, other->islastblockcomplete_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LocatedBlocksProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void HdfsFileStatusProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_HdfsFileStatusProto_default_instance_._instance
      .get_mutable()
      ->permission_ = const_cast<::Hdfs::Internal::FsPermissionProto*>(
      ::Hdfs::Internal::FsPermissionProto::internal_default_instance());
  ::Hdfs::Internal::_HdfsFileStatusProto_default_instance_._instance
      .get_mutable()
      ->locations_ = const_cast<::Hdfs::Internal::LocatedBlocksProto*>(
      ::Hdfs::Internal::LocatedBlocksProto::internal_default_instance());
  ::Hdfs::Internal::_HdfsFileStatusProto_default_instance_._instance
      .get_mutable()
      ->fileencryptioninfo_ = const_cast<
      ::Hdfs::Internal::FileEncryptionInfoProto*>(
      ::Hdfs::Internal::FileEncryptionInfoProto::internal_default_instance());
}
class HdfsFileStatusProto::_Internal {
 public:
  using HasBits = decltype(std::declval<HdfsFileStatusProto>()._has_bits_);
  static void set_has_filetype(HasBits* has_bits) { (*has_bits)[0] |= 8192u; }
  static void set_has_path(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_length(HasBits* has_bits) { (*has_bits)[0] |= 128u; }
  static const ::Hdfs::Internal::FsPermissionProto& permission(
      const HdfsFileStatusProto* msg);
  static void set_has_permission(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_owner(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_group(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_modification_time(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_access_time(HasBits* has_bits) { (*has_bits)[0] |= 512u; }
  static void set_has_symlink(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_block_replication(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_blocksize(HasBits* has_bits) { (*has_bits)[0] |= 1024u; }
  static const ::Hdfs::Internal::LocatedBlocksProto& locations(
      const HdfsFileStatusProto* msg);
  static void set_has_locations(HasBits* has_bits) { (*has_bits)[0] |= 32u; }
  static void set_has_fileid(HasBits* has_bits) { (*has_bits)[0] |= 2048u; }
  static void set_has_childrennum(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::Hdfs::Internal::FileEncryptionInfoProto& fileencryptioninfo(
      const HdfsFileStatusProto* msg);
  static void set_has_fileencryptioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::Hdfs::Internal::FsPermissionProto&
HdfsFileStatusProto::_Internal::permission(const HdfsFileStatusProto* msg) {
  return *msg->permission_;
}
const ::Hdfs::Internal::LocatedBlocksProto&
HdfsFileStatusProto::_Internal::locations(const HdfsFileStatusProto* msg) {
  return *msg->locations_;
}
const ::Hdfs::Internal::FileEncryptionInfoProto&
HdfsFileStatusProto::_Internal::fileencryptioninfo(
    const HdfsFileStatusProto* msg) {
  return *msg->fileencryptioninfo_;
}
HdfsFileStatusProto::HdfsFileStatusProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.HdfsFileStatusProto)
}
HdfsFileStatusProto::HdfsFileStatusProto(const HdfsFileStatusProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  path_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_path()) {
    path_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.path_);
  }
  owner_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_owner()) {
    owner_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.owner_);
  }
  group_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_group()) {
    group_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.group_);
  }
  symlink_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_symlink()) {
    symlink_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.symlink_);
  }
  if (from._internal_has_permission()) {
    permission_ = new ::Hdfs::Internal::FsPermissionProto(*from.permission_);
  } else {
    permission_ = nullptr;
  }
  if (from._internal_has_locations()) {
    locations_ = new ::Hdfs::Internal::LocatedBlocksProto(*from.locations_);
  } else {
    locations_ = nullptr;
  }
  if (from._internal_has_fileencryptioninfo()) {
    fileencryptioninfo_ = new ::Hdfs::Internal::FileEncryptionInfoProto(
        *from.fileencryptioninfo_);
  } else {
    fileencryptioninfo_ = nullptr;
  }
  ::memcpy(&length_, &from.length_,
           static_cast<size_t>(reinterpret_cast<char*>(&childrennum_) -
                               reinterpret_cast<char*>(&length_)) +
               sizeof(childrennum_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.HdfsFileStatusProto)
}

void HdfsFileStatusProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_HdfsFileStatusProto_hdfs_2eproto.base);
  path_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  owner_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  symlink_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&permission_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&block_replication_) -
                               reinterpret_cast<char*>(&permission_)) +
               sizeof(block_replication_));
  filetype_ = 1;
  childrennum_ = -1;
}

HdfsFileStatusProto::~HdfsFileStatusProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.HdfsFileStatusProto)
  SharedDtor();
}

void HdfsFileStatusProto::SharedDtor() {
  path_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  owner_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  symlink_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete permission_;
  if (this != internal_default_instance()) delete locations_;
  if (this != internal_default_instance()) delete fileencryptioninfo_;
}

void HdfsFileStatusProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HdfsFileStatusProto& HdfsFileStatusProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_HdfsFileStatusProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void HdfsFileStatusProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.HdfsFileStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      path_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      owner_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      group_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      symlink_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(permission_ != nullptr);
      permission_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(locations_ != nullptr);
      locations_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(fileencryptioninfo_ != nullptr);
      fileencryptioninfo_->Clear();
    }
  }
  length_ = PROTOBUF_ULONGLONG(0);
  if (cached_has_bits & 0x00007f00u) {
    ::memset(&modification_time_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&block_replication_) -
                                 reinterpret_cast<char*>(&modification_time_)) +
                 sizeof(block_replication_));
    filetype_ = 1;
    childrennum_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* HdfsFileStatusProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::HdfsFileStatusProto_FileType_IsValid(
                      val))) {
            _internal_set_filetype(
                static_cast<::Hdfs::Internal::HdfsFileStatusProto_FileType>(
                    val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required bytes path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.FsPermissionProto permission = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_permission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string owner = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_owner();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.HdfsFileStatusProto.owner");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_group();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.HdfsFileStatusProto.group");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 modification_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_modification_time(&has_bits);
          modification_time_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 access_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_access_time(&has_bits);
          access_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes symlink = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          auto str = _internal_mutable_symlink();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 block_replication = 10 [default = 0];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_block_replication(&has_bits);
          block_replication_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 blocksize = 11 [default = 0];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_blocksize(&has_bits);
          blocksize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.LocatedBlocksProto locations = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_locations(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fileId = 13 [default = 0];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_fileid(&has_bits);
          fileid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 childrenNum = 14 [default = -1];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_childrennum(&has_bits);
          childrennum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.FileEncryptionInfoProto fileEncryptionInfo =
      // 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_fileencryptioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* HdfsFileStatusProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.HdfsFileStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            1, this->_internal_filetype(), target);
  }

  // required bytes path = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(2, this->_internal_path(), target);
  }

  // required uint64 length = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_length(), target);
  }

  // required .Hdfs.Internal.FsPermissionProto permission = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::permission(this), target, stream);
  }

  // required string owner = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_owner().data(),
        static_cast<int>(this->_internal_owner().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.HdfsFileStatusProto.owner");
    target =
        stream->WriteStringMaybeAliased(5, this->_internal_owner(), target);
  }

  // required string group = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_group().data(),
        static_cast<int>(this->_internal_group().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.HdfsFileStatusProto.group");
    target =
        stream->WriteStringMaybeAliased(6, this->_internal_group(), target);
  }

  // required uint64 modification_time = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            7, this->_internal_modification_time(), target);
  }

  // required uint64 access_time = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            8, this->_internal_access_time(), target);
  }

  // optional bytes symlink = 9;
  if (cached_has_bits & 0x00000008u) {
    target =
        stream->WriteBytesMaybeAliased(9, this->_internal_symlink(), target);
  }

  // optional uint32 block_replication = 10 [default = 0];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            10, this->_internal_block_replication(), target);
  }

  // optional uint64 blocksize = 11 [default = 0];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            11, this->_internal_blocksize(), target);
  }

  // optional .Hdfs.Internal.LocatedBlocksProto locations = 12;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            12, _Internal::locations(this), target, stream);
  }

  // optional uint64 fileId = 13 [default = 0];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            13, this->_internal_fileid(), target);
  }

  // optional int32 childrenNum = 14 [default = -1];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(
            14, this->_internal_childrennum(), target);
  }

  // optional .Hdfs.Internal.FileEncryptionInfoProto fileEncryptionInfo = 15;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::fileencryptioninfo(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.HdfsFileStatusProto)
  return target;
}

size_t HdfsFileStatusProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.HdfsFileStatusProto)
  size_t total_size = 0;

  if (_internal_has_path()) {
    // required bytes path = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_path());
  }

  if (_internal_has_owner()) {
    // required string owner = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_owner());
  }

  if (_internal_has_group()) {
    // required string group = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_group());
  }

  if (_internal_has_permission()) {
    // required .Hdfs.Internal.FsPermissionProto permission = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *permission_);
  }

  if (_internal_has_length()) {
    // required uint64 length = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_length());
  }

  if (_internal_has_modification_time()) {
    // required uint64 modification_time = 7;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_modification_time());
  }

  if (_internal_has_access_time()) {
    // required uint64 access_time = 8;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_access_time());
  }

  if (_internal_has_filetype()) {
    // required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_filetype());
  }

  return total_size;
}
size_t HdfsFileStatusProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.HdfsFileStatusProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00002397) ^ 0x00002397) ==
      0) {  // All required fields are present.
    // required bytes path = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_path());

    // required string owner = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_owner());

    // required string group = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_group());

    // required .Hdfs.Internal.FsPermissionProto permission = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *permission_);

    // required uint64 length = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_length());

    // required uint64 modification_time = 7;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_modification_time());

    // required uint64 access_time = 8;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_access_time());

    // required .Hdfs.Internal.HdfsFileStatusProto.FileType fileType = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_filetype());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional bytes symlink = 9;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_symlink());
  }

  if (cached_has_bits & 0x00000060u) {
    // optional .Hdfs.Internal.LocatedBlocksProto locations = 12;
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                  *locations_);
    }

    // optional .Hdfs.Internal.FileEncryptionInfoProto fileEncryptionInfo = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                  *fileencryptioninfo_);
    }
  }
  if (cached_has_bits & 0x00001c00u) {
    // optional uint64 blocksize = 11 [default = 0];
    if (cached_has_bits & 0x00000400u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_blocksize());
    }

    // optional uint64 fileId = 13 [default = 0];
    if (cached_has_bits & 0x00000800u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_fileid());
    }

    // optional uint32 block_replication = 10 [default = 0];
    if (cached_has_bits & 0x00001000u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                  this->_internal_block_replication());
    }
  }
  // optional int32 childrenNum = 14 [default = -1];
  if (cached_has_bits & 0x00004000u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
                this->_internal_childrennum());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HdfsFileStatusProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.HdfsFileStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  const HdfsFileStatusProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HdfsFileStatusProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.HdfsFileStatusProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.HdfsFileStatusProto)
    MergeFrom(*source);
  }
}

void HdfsFileStatusProto::MergeFrom(const HdfsFileStatusProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.HdfsFileStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      path_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.path_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      owner_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.owner_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      group_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.group_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      symlink_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.symlink_);
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_permission()
          ->::Hdfs::Internal::FsPermissionProto::MergeFrom(
              from._internal_permission());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_locations()
          ->::Hdfs::Internal::LocatedBlocksProto::MergeFrom(
              from._internal_locations());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_fileencryptioninfo()
          ->::Hdfs::Internal::FileEncryptionInfoProto::MergeFrom(
              from._internal_fileencryptioninfo());
    }
    if (cached_has_bits & 0x00000080u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      modification_time_ = from.modification_time_;
    }
    if (cached_has_bits & 0x00000200u) {
      access_time_ = from.access_time_;
    }
    if (cached_has_bits & 0x00000400u) {
      blocksize_ = from.blocksize_;
    }
    if (cached_has_bits & 0x00000800u) {
      fileid_ = from.fileid_;
    }
    if (cached_has_bits & 0x00001000u) {
      block_replication_ = from.block_replication_;
    }
    if (cached_has_bits & 0x00002000u) {
      filetype_ = from.filetype_;
    }
    if (cached_has_bits & 0x00004000u) {
      childrennum_ = from.childrennum_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void HdfsFileStatusProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.HdfsFileStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HdfsFileStatusProto::CopyFrom(const HdfsFileStatusProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.HdfsFileStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HdfsFileStatusProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00002397) != 0x00002397) return false;
  if (_internal_has_permission()) {
    if (!permission_->IsInitialized()) return false;
  }
  if (_internal_has_locations()) {
    if (!locations_->IsInitialized()) return false;
  }
  if (_internal_has_fileencryptioninfo()) {
    if (!fileencryptioninfo_->IsInitialized()) return false;
  }
  return true;
}

void HdfsFileStatusProto::InternalSwap(HdfsFileStatusProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_.Swap(&other->path_,
             &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
             GetArenaNoVirtual());
  owner_.Swap(&other->owner_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  group_.Swap(&other->group_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  symlink_.Swap(
      &other->symlink_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(permission_, other->permission_);
  swap(locations_, other->locations_);
  swap(fileencryptioninfo_, other->fileencryptioninfo_);
  swap(length_, other->length_);
  swap(modification_time_, other->modification_time_);
  swap(access_time_, other->access_time_);
  swap(blocksize_, other->blocksize_);
  swap(fileid_, other->fileid_);
  swap(block_replication_, other->block_replication_);
  swap(filetype_, other->filetype_);
  swap(childrennum_, other->childrennum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HdfsFileStatusProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void FsServerDefaultsProto::InitAsDefaultInstance() {}
class FsServerDefaultsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<FsServerDefaultsProto>()._has_bits_);
  static void set_has_blocksize(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_bytesperchecksum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_writepacketsize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_replication(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_filebuffersize(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_encryptdatatransfer(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_trashinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_checksumtype(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

FsServerDefaultsProto::FsServerDefaultsProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.FsServerDefaultsProto)
}
FsServerDefaultsProto::FsServerDefaultsProto(const FsServerDefaultsProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&blocksize_, &from.blocksize_,
           static_cast<size_t>(reinterpret_cast<char*>(&checksumtype_) -
                               reinterpret_cast<char*>(&blocksize_)) +
               sizeof(checksumtype_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.FsServerDefaultsProto)
}

void FsServerDefaultsProto::SharedCtor() {
  ::memset(&blocksize_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&encryptdatatransfer_) -
                               reinterpret_cast<char*>(&blocksize_)) +
               sizeof(encryptdatatransfer_));
  checksumtype_ = 1;
}

FsServerDefaultsProto::~FsServerDefaultsProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.FsServerDefaultsProto)
  SharedDtor();
}

void FsServerDefaultsProto::SharedDtor() {}

void FsServerDefaultsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FsServerDefaultsProto& FsServerDefaultsProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_FsServerDefaultsProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void FsServerDefaultsProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.FsServerDefaultsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(
        &blocksize_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&encryptdatatransfer_) -
                            reinterpret_cast<char*>(&blocksize_)) +
            sizeof(encryptdatatransfer_));
    checksumtype_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FsServerDefaultsProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 blockSize = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_blocksize(&has_bits);
          blocksize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 bytesPerChecksum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_bytesperchecksum(&has_bits);
          bytesperchecksum_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 writePacketSize = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_writepacketsize(&has_bits);
          writepacketsize_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 replication = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_replication(&has_bits);
          replication_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 fileBufferSize = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_filebuffersize(&has_bits);
          filebuffersize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encryptDataTransfer = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_encryptdatatransfer(&has_bits);
          encryptdatatransfer_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 trashInterval = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_trashinterval(&has_bits);
          trashinterval_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.ChecksumTypeProto checksumType = 8 [default =
      // CHECKSUM_CRC32];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::ChecksumTypeProto_IsValid(val))) {
            _internal_set_checksumtype(
                static_cast<::Hdfs::Internal::ChecksumTypeProto>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FsServerDefaultsProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.FsServerDefaultsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 blockSize = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_blocksize(), target);
  }

  // required uint32 bytesPerChecksum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            2, this->_internal_bytesperchecksum(), target);
  }

  // required uint32 writePacketSize = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            3, this->_internal_writepacketsize(), target);
  }

  // required uint32 replication = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            4, this->_internal_replication(), target);
  }

  // required uint32 fileBufferSize = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            5, this->_internal_filebuffersize(), target);
  }

  // optional bool encryptDataTransfer = 6 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            6, this->_internal_encryptdatatransfer(), target);
  }

  // optional uint64 trashInterval = 7 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            7, this->_internal_trashinterval(), target);
  }

  // optional .Hdfs.Internal.ChecksumTypeProto checksumType = 8 [default =
  // CHECKSUM_CRC32];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            8, this->_internal_checksumtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.FsServerDefaultsProto)
  return target;
}

size_t FsServerDefaultsProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.FsServerDefaultsProto)
  size_t total_size = 0;

  if (_internal_has_blocksize()) {
    // required uint64 blockSize = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blocksize());
  }

  if (_internal_has_bytesperchecksum()) {
    // required uint32 bytesPerChecksum = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_bytesperchecksum());
  }

  if (_internal_has_writepacketsize()) {
    // required uint32 writePacketSize = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_writepacketsize());
  }

  if (_internal_has_replication()) {
    // required uint32 replication = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_replication());
  }

  if (_internal_has_filebuffersize()) {
    // required uint32 fileBufferSize = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_filebuffersize());
  }

  return total_size;
}
size_t FsServerDefaultsProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.FsServerDefaultsProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) ==
      0) {  // All required fields are present.
    // required uint64 blockSize = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blocksize());

    // required uint32 bytesPerChecksum = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_bytesperchecksum());

    // required uint32 writePacketSize = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_writepacketsize());

    // required uint32 replication = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_replication());

    // required uint32 fileBufferSize = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_filebuffersize());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000e0u) {
    // optional uint64 trashInterval = 7 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                  this->_internal_trashinterval());
    }

    // optional bool encryptDataTransfer = 6 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional .Hdfs.Internal.ChecksumTypeProto checksumType = 8 [default =
    // CHECKSUM_CRC32];
    if (cached_has_bits & 0x00000080u) {
      total_size +=
          1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                  this->_internal_checksumtype());
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FsServerDefaultsProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.FsServerDefaultsProto)
  GOOGLE_DCHECK_NE(&from, this);
  const FsServerDefaultsProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FsServerDefaultsProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.FsServerDefaultsProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.FsServerDefaultsProto)
    MergeFrom(*source);
  }
}

void FsServerDefaultsProto::MergeFrom(const FsServerDefaultsProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.FsServerDefaultsProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      blocksize_ = from.blocksize_;
    }
    if (cached_has_bits & 0x00000002u) {
      bytesperchecksum_ = from.bytesperchecksum_;
    }
    if (cached_has_bits & 0x00000004u) {
      writepacketsize_ = from.writepacketsize_;
    }
    if (cached_has_bits & 0x00000008u) {
      replication_ = from.replication_;
    }
    if (cached_has_bits & 0x00000010u) {
      filebuffersize_ = from.filebuffersize_;
    }
    if (cached_has_bits & 0x00000020u) {
      trashinterval_ = from.trashinterval_;
    }
    if (cached_has_bits & 0x00000040u) {
      encryptdatatransfer_ = from.encryptdatatransfer_;
    }
    if (cached_has_bits & 0x00000080u) {
      checksumtype_ = from.checksumtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FsServerDefaultsProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.FsServerDefaultsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FsServerDefaultsProto::CopyFrom(const FsServerDefaultsProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.FsServerDefaultsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FsServerDefaultsProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  return true;
}

void FsServerDefaultsProto::InternalSwap(FsServerDefaultsProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(blocksize_, other->blocksize_);
  swap(bytesperchecksum_, other->bytesperchecksum_);
  swap(writepacketsize_, other->writepacketsize_);
  swap(replication_, other->replication_);
  swap(filebuffersize_, other->filebuffersize_);
  swap(trashinterval_, other->trashinterval_);
  swap(encryptdatatransfer_, other->encryptdatatransfer_);
  swap(checksumtype_, other->checksumtype_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FsServerDefaultsProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void DirectoryListingProto::InitAsDefaultInstance() {}
class DirectoryListingProto::_Internal {
 public:
  using HasBits = decltype(std::declval<DirectoryListingProto>()._has_bits_);
  static void set_has_remainingentries(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

DirectoryListingProto::DirectoryListingProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.DirectoryListingProto)
}
DirectoryListingProto::DirectoryListingProto(const DirectoryListingProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      partiallisting_(from.partiallisting_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  remainingentries_ = from.remainingentries_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.DirectoryListingProto)
}

void DirectoryListingProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_DirectoryListingProto_hdfs_2eproto.base);
  remainingentries_ = 0u;
}

DirectoryListingProto::~DirectoryListingProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.DirectoryListingProto)
  SharedDtor();
}

void DirectoryListingProto::SharedDtor() {}

void DirectoryListingProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const DirectoryListingProto& DirectoryListingProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_DirectoryListingProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void DirectoryListingProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.DirectoryListingProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  partiallisting_.Clear();
  remainingentries_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* DirectoryListingProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Hdfs.Internal.HdfsFileStatusProto partialListing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_partiallisting(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required uint32 remainingEntries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_remainingentries(&has_bits);
          remainingentries_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DirectoryListingProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.DirectoryListingProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.HdfsFileStatusProto partialListing = 1;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_partiallisting_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, this->_internal_partiallisting(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // required uint32 remainingEntries = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            2, this->_internal_remainingentries(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.DirectoryListingProto)
  return target;
}

size_t DirectoryListingProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.DirectoryListingProto)
  size_t total_size = 0;

  // required uint32 remainingEntries = 2;
  if (_internal_has_remainingentries()) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_remainingentries());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.HdfsFileStatusProto partialListing = 1;
  total_size += 1UL * this->_internal_partiallisting_size();
  for (const auto& msg : this->partiallisting_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DirectoryListingProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.DirectoryListingProto)
  GOOGLE_DCHECK_NE(&from, this);
  const DirectoryListingProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<DirectoryListingProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.DirectoryListingProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.DirectoryListingProto)
    MergeFrom(*source);
  }
}

void DirectoryListingProto::MergeFrom(const DirectoryListingProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.DirectoryListingProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  partiallisting_.MergeFrom(from.partiallisting_);
  if (from._internal_has_remainingentries()) {
    _internal_set_remainingentries(from._internal_remainingentries());
  }
}

void DirectoryListingProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.DirectoryListingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DirectoryListingProto::CopyFrom(const DirectoryListingProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.DirectoryListingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectoryListingProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(partiallisting_))
    return false;
  return true;
}

void DirectoryListingProto::InternalSwap(DirectoryListingProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  partiallisting_.InternalSwap(&other->partiallisting_);
  swap(remainingentries_, other->remainingentries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DirectoryListingProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void SnapshottableDirectoryStatusProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_SnapshottableDirectoryStatusProto_default_instance_
      ._instance.get_mutable()
      ->dirstatus_ = const_cast<::Hdfs::Internal::HdfsFileStatusProto*>(
      ::Hdfs::Internal::HdfsFileStatusProto::internal_default_instance());
}
class SnapshottableDirectoryStatusProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SnapshottableDirectoryStatusProto>()._has_bits_);
  static const ::Hdfs::Internal::HdfsFileStatusProto& dirstatus(
      const SnapshottableDirectoryStatusProto* msg);
  static void set_has_dirstatus(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_snapshot_quota(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_snapshot_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_parent_fullpath(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::Hdfs::Internal::HdfsFileStatusProto&
SnapshottableDirectoryStatusProto::_Internal::dirstatus(
    const SnapshottableDirectoryStatusProto* msg) {
  return *msg->dirstatus_;
}
SnapshottableDirectoryStatusProto::SnapshottableDirectoryStatusProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.SnapshottableDirectoryStatusProto)
}
SnapshottableDirectoryStatusProto::SnapshottableDirectoryStatusProto(
    const SnapshottableDirectoryStatusProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  parent_fullpath_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_parent_fullpath()) {
    parent_fullpath_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.parent_fullpath_);
  }
  if (from._internal_has_dirstatus()) {
    dirstatus_ = new ::Hdfs::Internal::HdfsFileStatusProto(*from.dirstatus_);
  } else {
    dirstatus_ = nullptr;
  }
  ::memcpy(&snapshot_quota_, &from.snapshot_quota_,
           static_cast<size_t>(reinterpret_cast<char*>(&snapshot_number_) -
                               reinterpret_cast<char*>(&snapshot_quota_)) +
               sizeof(snapshot_number_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.SnapshottableDirectoryStatusProto)
}

void SnapshottableDirectoryStatusProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto.base);
  parent_fullpath_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&dirstatus_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&snapshot_number_) -
                               reinterpret_cast<char*>(&dirstatus_)) +
               sizeof(snapshot_number_));
}

SnapshottableDirectoryStatusProto::~SnapshottableDirectoryStatusProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  SharedDtor();
}

void SnapshottableDirectoryStatusProto::SharedDtor() {
  parent_fullpath_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete dirstatus_;
}

void SnapshottableDirectoryStatusProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SnapshottableDirectoryStatusProto&
SnapshottableDirectoryStatusProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_SnapshottableDirectoryStatusProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void SnapshottableDirectoryStatusProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      parent_fullpath_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dirstatus_ != nullptr);
      dirstatus_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&snapshot_quota_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&snapshot_number_) -
                                 reinterpret_cast<char*>(&snapshot_quota_)) +
                 sizeof(snapshot_number_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* SnapshottableDirectoryStatusProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_dirstatus(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 snapshot_quota = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_snapshot_quota(&has_bits);
          snapshot_quota_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 snapshot_number = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_snapshot_number(&has_bits);
          snapshot_number_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes parent_fullpath = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_parent_fullpath();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8*
SnapshottableDirectoryStatusProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::dirstatus(this), target, stream);
  }

  // required uint32 snapshot_quota = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            2, this->_internal_snapshot_quota(), target);
  }

  // required uint32 snapshot_number = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            3, this->_internal_snapshot_number(), target);
  }

  // required bytes parent_fullpath = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_parent_fullpath(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  return target;
}

size_t SnapshottableDirectoryStatusProto::RequiredFieldsByteSizeFallback()
    const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  size_t total_size = 0;

  if (_internal_has_parent_fullpath()) {
    // required bytes parent_fullpath = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_parent_fullpath());
  }

  if (_internal_has_dirstatus()) {
    // required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *dirstatus_);
  }

  if (_internal_has_snapshot_quota()) {
    // required uint32 snapshot_quota = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_snapshot_quota());
  }

  if (_internal_has_snapshot_number()) {
    // required uint32 snapshot_number = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_snapshot_number());
  }

  return total_size;
}
size_t SnapshottableDirectoryStatusProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) ==
      0) {  // All required fields are present.
    // required bytes parent_fullpath = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_parent_fullpath());

    // required .Hdfs.Internal.HdfsFileStatusProto dirStatus = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *dirstatus_);

    // required uint32 snapshot_quota = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_snapshot_quota());

    // required uint32 snapshot_number = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_snapshot_number());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SnapshottableDirectoryStatusProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  const SnapshottableDirectoryStatusProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          SnapshottableDirectoryStatusProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.SnapshottableDirectoryStatusProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.SnapshottableDirectoryStatusProto)
    MergeFrom(*source);
  }
}

void SnapshottableDirectoryStatusProto::MergeFrom(
    const SnapshottableDirectoryStatusProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      parent_fullpath_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.parent_fullpath_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_dirstatus()
          ->::Hdfs::Internal::HdfsFileStatusProto::MergeFrom(
              from._internal_dirstatus());
    }
    if (cached_has_bits & 0x00000004u) {
      snapshot_quota_ = from.snapshot_quota_;
    }
    if (cached_has_bits & 0x00000008u) {
      snapshot_number_ = from.snapshot_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SnapshottableDirectoryStatusProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshottableDirectoryStatusProto::CopyFrom(
    const SnapshottableDirectoryStatusProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.SnapshottableDirectoryStatusProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshottableDirectoryStatusProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  if (_internal_has_dirstatus()) {
    if (!dirstatus_->IsInitialized()) return false;
  }
  return true;
}

void SnapshottableDirectoryStatusProto::InternalSwap(
    SnapshottableDirectoryStatusProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  parent_fullpath_.Swap(
      &other->parent_fullpath_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(dirstatus_, other->dirstatus_);
  swap(snapshot_quota_, other->snapshot_quota_);
  swap(snapshot_number_, other->snapshot_number_);
}

::PROTOBUF_NAMESPACE_ID::Metadata
SnapshottableDirectoryStatusProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void SnapshottableDirectoryListingProto::InitAsDefaultInstance() {}
class SnapshottableDirectoryListingProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SnapshottableDirectoryListingProto>()._has_bits_);
};

SnapshottableDirectoryListingProto::SnapshottableDirectoryListingProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.SnapshottableDirectoryListingProto)
}
SnapshottableDirectoryListingProto::SnapshottableDirectoryListingProto(
    const SnapshottableDirectoryListingProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      snapshottabledirlisting_(from.snapshottabledirlisting_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.SnapshottableDirectoryListingProto)
}

void SnapshottableDirectoryListingProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_SnapshottableDirectoryListingProto_hdfs_2eproto.base);
}

SnapshottableDirectoryListingProto::~SnapshottableDirectoryListingProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.SnapshottableDirectoryListingProto)
  SharedDtor();
}

void SnapshottableDirectoryListingProto::SharedDtor() {}

void SnapshottableDirectoryListingProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SnapshottableDirectoryListingProto&
SnapshottableDirectoryListingProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_SnapshottableDirectoryListingProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void SnapshottableDirectoryListingProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  snapshottabledirlisting_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* SnapshottableDirectoryListingProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Hdfs.Internal.SnapshottableDirectoryStatusProto
      // snapshottableDirListing = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr =
                ctx->ParseMessage(_internal_add_snapshottabledirlisting(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8*
SnapshottableDirectoryListingProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.SnapshottableDirectoryStatusProto
  // snapshottableDirListing = 1;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_snapshottabledirlisting_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, this->_internal_snapshottabledirlisting(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.SnapshottableDirectoryListingProto)
  return target;
}

size_t SnapshottableDirectoryListingProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.SnapshottableDirectoryStatusProto
  // snapshottableDirListing = 1;
  total_size += 1UL * this->_internal_snapshottabledirlisting_size();
  for (const auto& msg : this->snapshottabledirlisting_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SnapshottableDirectoryListingProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  GOOGLE_DCHECK_NE(&from, this);
  const SnapshottableDirectoryListingProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          SnapshottableDirectoryListingProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.SnapshottableDirectoryListingProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.SnapshottableDirectoryListingProto)
    MergeFrom(*source);
  }
}

void SnapshottableDirectoryListingProto::MergeFrom(
    const SnapshottableDirectoryListingProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  snapshottabledirlisting_.MergeFrom(from.snapshottabledirlisting_);
}

void SnapshottableDirectoryListingProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshottableDirectoryListingProto::CopyFrom(
    const SnapshottableDirectoryListingProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.SnapshottableDirectoryListingProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshottableDirectoryListingProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(
          snapshottabledirlisting_))
    return false;
  return true;
}

void SnapshottableDirectoryListingProto::InternalSwap(
    SnapshottableDirectoryListingProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  snapshottabledirlisting_.InternalSwap(&other->snapshottabledirlisting_);
}

::PROTOBUF_NAMESPACE_ID::Metadata
SnapshottableDirectoryListingProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void SnapshotDiffReportEntryProto::InitAsDefaultInstance() {}
class SnapshotDiffReportEntryProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SnapshotDiffReportEntryProto>()._has_bits_);
  static void set_has_fullpath(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_modificationlabel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SnapshotDiffReportEntryProto::SnapshotDiffReportEntryProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.SnapshotDiffReportEntryProto)
}
SnapshotDiffReportEntryProto::SnapshotDiffReportEntryProto(
    const SnapshotDiffReportEntryProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  fullpath_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_fullpath()) {
    fullpath_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.fullpath_);
  }
  modificationlabel_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_modificationlabel()) {
    modificationlabel_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.modificationlabel_);
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.SnapshotDiffReportEntryProto)
}

void SnapshotDiffReportEntryProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto.base);
  fullpath_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  modificationlabel_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SnapshotDiffReportEntryProto::~SnapshotDiffReportEntryProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.SnapshotDiffReportEntryProto)
  SharedDtor();
}

void SnapshotDiffReportEntryProto::SharedDtor() {
  fullpath_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  modificationlabel_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SnapshotDiffReportEntryProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SnapshotDiffReportEntryProto&
SnapshotDiffReportEntryProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_SnapshotDiffReportEntryProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void SnapshotDiffReportEntryProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      fullpath_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      modificationlabel_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* SnapshotDiffReportEntryProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes fullpath = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_fullpath();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string modificationLabel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_modificationlabel();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str,
              "Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8*
SnapshotDiffReportEntryProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes fullpath = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
        stream->WriteBytesMaybeAliased(1, this->_internal_fullpath(), target);
  }

  // required string modificationLabel = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_modificationlabel().data(),
        static_cast<int>(this->_internal_modificationlabel().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotDiffReportEntryProto.modificationLabel");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_modificationlabel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.SnapshotDiffReportEntryProto)
  return target;
}

size_t SnapshotDiffReportEntryProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  size_t total_size = 0;

  if (_internal_has_fullpath()) {
    // required bytes fullpath = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_fullpath());
  }

  if (_internal_has_modificationlabel()) {
    // required string modificationLabel = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_modificationlabel());
  }

  return total_size;
}
size_t SnapshotDiffReportEntryProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) ==
      0) {  // All required fields are present.
    // required bytes fullpath = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_fullpath());

    // required string modificationLabel = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_modificationlabel());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SnapshotDiffReportEntryProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  GOOGLE_DCHECK_NE(&from, this);
  const SnapshotDiffReportEntryProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          SnapshotDiffReportEntryProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.SnapshotDiffReportEntryProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.SnapshotDiffReportEntryProto)
    MergeFrom(*source);
  }
}

void SnapshotDiffReportEntryProto::MergeFrom(
    const SnapshotDiffReportEntryProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      fullpath_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.fullpath_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      modificationlabel_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.modificationlabel_);
    }
  }
}

void SnapshotDiffReportEntryProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotDiffReportEntryProto::CopyFrom(
    const SnapshotDiffReportEntryProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.SnapshotDiffReportEntryProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotDiffReportEntryProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void SnapshotDiffReportEntryProto::InternalSwap(
    SnapshotDiffReportEntryProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  fullpath_.Swap(
      &other->fullpath_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  modificationlabel_.Swap(
      &other->modificationlabel_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotDiffReportEntryProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void SnapshotDiffReportProto::InitAsDefaultInstance() {}
class SnapshotDiffReportProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SnapshotDiffReportProto>()._has_bits_);
  static void set_has_snapshotroot(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_fromsnapshot(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_tosnapshot(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
};

SnapshotDiffReportProto::SnapshotDiffReportProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.SnapshotDiffReportProto)
}
SnapshotDiffReportProto::SnapshotDiffReportProto(
    const SnapshotDiffReportProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      diffreportentries_(from.diffreportentries_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  snapshotroot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_snapshotroot()) {
    snapshotroot_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.snapshotroot_);
  }
  fromsnapshot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_fromsnapshot()) {
    fromsnapshot_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.fromsnapshot_);
  }
  tosnapshot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_tosnapshot()) {
    tosnapshot_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.tosnapshot_);
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.SnapshotDiffReportProto)
}

void SnapshotDiffReportProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_SnapshotDiffReportProto_hdfs_2eproto.base);
  snapshotroot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fromsnapshot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tosnapshot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SnapshotDiffReportProto::~SnapshotDiffReportProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.SnapshotDiffReportProto)
  SharedDtor();
}

void SnapshotDiffReportProto::SharedDtor() {
  snapshotroot_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  fromsnapshot_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  tosnapshot_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SnapshotDiffReportProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SnapshotDiffReportProto& SnapshotDiffReportProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_SnapshotDiffReportProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void SnapshotDiffReportProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.SnapshotDiffReportProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  diffreportentries_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      snapshotroot_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      fromsnapshot_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      tosnapshot_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* SnapshotDiffReportProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string snapshotRoot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_snapshotroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string fromSnapshot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_fromsnapshot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string toSnapshot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_tosnapshot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotDiffReportProto.toSnapshot");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Hdfs.Internal.SnapshotDiffReportEntryProto diffReportEntries
      // = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_diffreportentries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SnapshotDiffReportProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.SnapshotDiffReportProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string snapshotRoot = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_snapshotroot().data(),
        static_cast<int>(this->_internal_snapshotroot().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotDiffReportProto.snapshotRoot");
    target = stream->WriteStringMaybeAliased(1, this->_internal_snapshotroot(),
                                             target);
  }

  // required string fromSnapshot = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_fromsnapshot().data(),
        static_cast<int>(this->_internal_fromsnapshot().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotDiffReportProto.fromSnapshot");
    target = stream->WriteStringMaybeAliased(2, this->_internal_fromsnapshot(),
                                             target);
  }

  // required string toSnapshot = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_tosnapshot().data(),
        static_cast<int>(this->_internal_tosnapshot().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotDiffReportProto.toSnapshot");
    target = stream->WriteStringMaybeAliased(3, this->_internal_tosnapshot(),
                                             target);
  }

  // repeated .Hdfs.Internal.SnapshotDiffReportEntryProto diffReportEntries = 4;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_diffreportentries_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, this->_internal_diffreportentries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.SnapshotDiffReportProto)
  return target;
}

size_t SnapshotDiffReportProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.SnapshotDiffReportProto)
  size_t total_size = 0;

  if (_internal_has_snapshotroot()) {
    // required string snapshotRoot = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotroot());
  }

  if (_internal_has_fromsnapshot()) {
    // required string fromSnapshot = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_fromsnapshot());
  }

  if (_internal_has_tosnapshot()) {
    // required string toSnapshot = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_tosnapshot());
  }

  return total_size;
}
size_t SnapshotDiffReportProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.SnapshotDiffReportProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) ==
      0) {  // All required fields are present.
    // required string snapshotRoot = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotroot());

    // required string fromSnapshot = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_fromsnapshot());

    // required string toSnapshot = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_tosnapshot());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.SnapshotDiffReportEntryProto diffReportEntries = 4;
  total_size += 1UL * this->_internal_diffreportentries_size();
  for (const auto& msg : this->diffreportentries_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SnapshotDiffReportProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.SnapshotDiffReportProto)
  GOOGLE_DCHECK_NE(&from, this);
  const SnapshotDiffReportProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SnapshotDiffReportProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.SnapshotDiffReportProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.SnapshotDiffReportProto)
    MergeFrom(*source);
  }
}

void SnapshotDiffReportProto::MergeFrom(const SnapshotDiffReportProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.SnapshotDiffReportProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  diffreportentries_.MergeFrom(from.diffreportentries_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      snapshotroot_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.snapshotroot_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      fromsnapshot_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.fromsnapshot_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      tosnapshot_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.tosnapshot_);
    }
  }
}

void SnapshotDiffReportProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.SnapshotDiffReportProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotDiffReportProto::CopyFrom(const SnapshotDiffReportProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.SnapshotDiffReportProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotDiffReportProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(diffreportentries_))
    return false;
  return true;
}

void SnapshotDiffReportProto::InternalSwap(SnapshotDiffReportProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  diffreportentries_.InternalSwap(&other->diffreportentries_);
  snapshotroot_.Swap(
      &other->snapshotroot_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  fromsnapshot_.Swap(
      &other->fromsnapshot_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  tosnapshot_.Swap(
      &other->tosnapshot_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotDiffReportProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void StorageInfoProto::InitAsDefaultInstance() {}
class StorageInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<StorageInfoProto>()._has_bits_);
  static void set_has_layoutversion(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_namespceid(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_clusterid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_ctime(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
};

StorageInfoProto::StorageInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.StorageInfoProto)
}
StorageInfoProto::StorageInfoProto(const StorageInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clusterid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_clusterid()) {
    clusterid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.clusterid_);
  }
  ::memcpy(&layoutversion_, &from.layoutversion_,
           static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
                               reinterpret_cast<char*>(&layoutversion_)) +
               sizeof(ctime_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.StorageInfoProto)
}

void StorageInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_StorageInfoProto_hdfs_2eproto.base);
  clusterid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&layoutversion_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
                               reinterpret_cast<char*>(&layoutversion_)) +
               sizeof(ctime_));
}

StorageInfoProto::~StorageInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.StorageInfoProto)
  SharedDtor();
}

void StorageInfoProto::SharedDtor() {
  clusterid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StorageInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StorageInfoProto& StorageInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_StorageInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void StorageInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.StorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    clusterid_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&layoutversion_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&ctime_) -
                                 reinterpret_cast<char*>(&layoutversion_)) +
                 sizeof(ctime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StorageInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 layoutVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_layoutversion(&has_bits);
          layoutversion_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 namespceID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_namespceid(&has_bits);
          namespceid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string clusterID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_clusterid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.StorageInfoProto.clusterID");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 cTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ctime(&has_bits);
          ctime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StorageInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.StorageInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 layoutVersion = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            1, this->_internal_layoutversion(), target);
  }

  // required uint32 namespceID = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            2, this->_internal_namespceid(), target);
  }

  // required string clusterID = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_clusterid().data(),
        static_cast<int>(this->_internal_clusterid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.StorageInfoProto.clusterID");
    target =
        stream->WriteStringMaybeAliased(3, this->_internal_clusterid(), target);
  }

  // required uint64 cTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            4, this->_internal_ctime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.StorageInfoProto)
  return target;
}

size_t StorageInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.StorageInfoProto)
  size_t total_size = 0;

  if (_internal_has_clusterid()) {
    // required string clusterID = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_clusterid());
  }

  if (_internal_has_layoutversion()) {
    // required uint32 layoutVersion = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_layoutversion());
  }

  if (_internal_has_namespceid()) {
    // required uint32 namespceID = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_namespceid());
  }

  if (_internal_has_ctime()) {
    // required uint64 cTime = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_ctime());
  }

  return total_size;
}
size_t StorageInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.StorageInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) ==
      0) {  // All required fields are present.
    // required string clusterID = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_clusterid());

    // required uint32 layoutVersion = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_layoutversion());

    // required uint32 namespceID = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_namespceid());

    // required uint64 cTime = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_ctime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StorageInfoProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.StorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const StorageInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StorageInfoProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.StorageInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.StorageInfoProto)
    MergeFrom(*source);
  }
}

void StorageInfoProto::MergeFrom(const StorageInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.StorageInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      clusterid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.clusterid_);
    }
    if (cached_has_bits & 0x00000002u) {
      layoutversion_ = from.layoutversion_;
    }
    if (cached_has_bits & 0x00000004u) {
      namespceid_ = from.namespceid_;
    }
    if (cached_has_bits & 0x00000008u) {
      ctime_ = from.ctime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StorageInfoProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.StorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StorageInfoProto::CopyFrom(const StorageInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.StorageInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StorageInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void StorageInfoProto::InternalSwap(StorageInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  clusterid_.Swap(
      &other->clusterid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(layoutversion_, other->layoutversion_);
  swap(namespceid_, other->namespceid_);
  swap(ctime_, other->ctime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StorageInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void NamenodeRegistrationProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_NamenodeRegistrationProto_default_instance_._instance
      .get_mutable()
      ->storageinfo_ = const_cast<::Hdfs::Internal::StorageInfoProto*>(
      ::Hdfs::Internal::StorageInfoProto::internal_default_instance());
}
class NamenodeRegistrationProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<NamenodeRegistrationProto>()._has_bits_);
  static void set_has_rpcaddress(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_httpaddress(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static const ::Hdfs::Internal::StorageInfoProto& storageinfo(
      const NamenodeRegistrationProto* msg);
  static void set_has_storageinfo(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_role(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
};

const ::Hdfs::Internal::StorageInfoProto&
NamenodeRegistrationProto::_Internal::storageinfo(
    const NamenodeRegistrationProto* msg) {
  return *msg->storageinfo_;
}
NamenodeRegistrationProto::NamenodeRegistrationProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.NamenodeRegistrationProto)
}
NamenodeRegistrationProto::NamenodeRegistrationProto(
    const NamenodeRegistrationProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  rpcaddress_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_rpcaddress()) {
    rpcaddress_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.rpcaddress_);
  }
  httpaddress_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_httpaddress()) {
    httpaddress_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.httpaddress_);
  }
  if (from._internal_has_storageinfo()) {
    storageinfo_ = new ::Hdfs::Internal::StorageInfoProto(*from.storageinfo_);
  } else {
    storageinfo_ = nullptr;
  }
  role_ = from.role_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.NamenodeRegistrationProto)
}

void NamenodeRegistrationProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_NamenodeRegistrationProto_hdfs_2eproto.base);
  rpcaddress_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  httpaddress_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  storageinfo_ = nullptr;
  role_ = 1;
}

NamenodeRegistrationProto::~NamenodeRegistrationProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.NamenodeRegistrationProto)
  SharedDtor();
}

void NamenodeRegistrationProto::SharedDtor() {
  rpcaddress_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  httpaddress_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete storageinfo_;
}

void NamenodeRegistrationProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NamenodeRegistrationProto& NamenodeRegistrationProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_NamenodeRegistrationProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void NamenodeRegistrationProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.NamenodeRegistrationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      rpcaddress_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      httpaddress_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(storageinfo_ != nullptr);
      storageinfo_->Clear();
    }
    role_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NamenodeRegistrationProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string rpcAddress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_rpcaddress();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.NamenodeRegistrationProto.rpcAddress");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string httpAddress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_httpaddress();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.NamenodeRegistrationProto.httpAddress");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_storageinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.NamenodeRegistrationProto.NamenodeRoleProto
      // role = 4 [default = NAMENODE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::
                      NamenodeRegistrationProto_NamenodeRoleProto_IsValid(
                          val))) {
            _internal_set_role(
                static_cast<::Hdfs::Internal::
                                NamenodeRegistrationProto_NamenodeRoleProto>(
                    val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NamenodeRegistrationProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.NamenodeRegistrationProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string rpcAddress = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_rpcaddress().data(),
        static_cast<int>(this->_internal_rpcaddress().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.NamenodeRegistrationProto.rpcAddress");
    target = stream->WriteStringMaybeAliased(1, this->_internal_rpcaddress(),
                                             target);
  }

  // required string httpAddress = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_httpaddress().data(),
        static_cast<int>(this->_internal_httpaddress().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.NamenodeRegistrationProto.httpAddress");
    target = stream->WriteStringMaybeAliased(2, this->_internal_httpaddress(),
                                             target);
  }

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::storageinfo(this), target, stream);
  }

  // optional .Hdfs.Internal.NamenodeRegistrationProto.NamenodeRoleProto role =
  // 4 [default = NAMENODE];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            4, this->_internal_role(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.NamenodeRegistrationProto)
  return target;
}

size_t NamenodeRegistrationProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.NamenodeRegistrationProto)
  size_t total_size = 0;

  if (_internal_has_rpcaddress()) {
    // required string rpcAddress = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_rpcaddress());
  }

  if (_internal_has_httpaddress()) {
    // required string httpAddress = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_httpaddress());
  }

  if (_internal_has_storageinfo()) {
    // required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);
  }

  return total_size;
}
size_t NamenodeRegistrationProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.NamenodeRegistrationProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) ==
      0) {  // All required fields are present.
    // required string rpcAddress = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_rpcaddress());

    // required string httpAddress = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_httpaddress());

    // required .Hdfs.Internal.StorageInfoProto storageInfo = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional .Hdfs.Internal.NamenodeRegistrationProto.NamenodeRoleProto role =
  // 4 [default = NAMENODE];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_role());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamenodeRegistrationProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.NamenodeRegistrationProto)
  GOOGLE_DCHECK_NE(&from, this);
  const NamenodeRegistrationProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          NamenodeRegistrationProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.NamenodeRegistrationProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.NamenodeRegistrationProto)
    MergeFrom(*source);
  }
}

void NamenodeRegistrationProto::MergeFrom(
    const NamenodeRegistrationProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.NamenodeRegistrationProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      rpcaddress_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.rpcaddress_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      httpaddress_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.httpaddress_);
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_storageinfo()
          ->::Hdfs::Internal::StorageInfoProto::MergeFrom(
              from._internal_storageinfo());
    }
    if (cached_has_bits & 0x00000008u) {
      role_ = from.role_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NamenodeRegistrationProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.NamenodeRegistrationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamenodeRegistrationProto::CopyFrom(
    const NamenodeRegistrationProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.NamenodeRegistrationProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamenodeRegistrationProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (_internal_has_storageinfo()) {
    if (!storageinfo_->IsInitialized()) return false;
  }
  return true;
}

void NamenodeRegistrationProto::InternalSwap(NamenodeRegistrationProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rpcaddress_.Swap(
      &other->rpcaddress_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  httpaddress_.Swap(
      &other->httpaddress_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(storageinfo_, other->storageinfo_);
  swap(role_, other->role_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamenodeRegistrationProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void CheckpointSignatureProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_CheckpointSignatureProto_default_instance_._instance
      .get_mutable()
      ->storageinfo_ = const_cast<::Hdfs::Internal::StorageInfoProto*>(
      ::Hdfs::Internal::StorageInfoProto::internal_default_instance());
}
class CheckpointSignatureProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckpointSignatureProto>()._has_bits_);
  static void set_has_blockpoolid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_mostrecentcheckpointtxid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cursegmenttxid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::Hdfs::Internal::StorageInfoProto& storageinfo(
      const CheckpointSignatureProto* msg);
  static void set_has_storageinfo(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
};

const ::Hdfs::Internal::StorageInfoProto&
CheckpointSignatureProto::_Internal::storageinfo(
    const CheckpointSignatureProto* msg) {
  return *msg->storageinfo_;
}
CheckpointSignatureProto::CheckpointSignatureProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.CheckpointSignatureProto)
}
CheckpointSignatureProto::CheckpointSignatureProto(
    const CheckpointSignatureProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blockpoolid()) {
    blockpoolid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.blockpoolid_);
  }
  if (from._internal_has_storageinfo()) {
    storageinfo_ = new ::Hdfs::Internal::StorageInfoProto(*from.storageinfo_);
  } else {
    storageinfo_ = nullptr;
  }
  ::memcpy(
      &mostrecentcheckpointtxid_, &from.mostrecentcheckpointtxid_,
      static_cast<size_t>(reinterpret_cast<char*>(&cursegmenttxid_) -
                          reinterpret_cast<char*>(&mostrecentcheckpointtxid_)) +
          sizeof(cursegmenttxid_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.CheckpointSignatureProto)
}

void CheckpointSignatureProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_CheckpointSignatureProto_hdfs_2eproto.base);
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&storageinfo_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&cursegmenttxid_) -
                               reinterpret_cast<char*>(&storageinfo_)) +
               sizeof(cursegmenttxid_));
}

CheckpointSignatureProto::~CheckpointSignatureProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.CheckpointSignatureProto)
  SharedDtor();
}

void CheckpointSignatureProto::SharedDtor() {
  blockpoolid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete storageinfo_;
}

void CheckpointSignatureProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckpointSignatureProto& CheckpointSignatureProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_CheckpointSignatureProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void CheckpointSignatureProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.CheckpointSignatureProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      blockpoolid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(storageinfo_ != nullptr);
      storageinfo_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&mostrecentcheckpointtxid_, 0,
             static_cast<size_t>(
                 reinterpret_cast<char*>(&cursegmenttxid_) -
                 reinterpret_cast<char*>(&mostrecentcheckpointtxid_)) +
                 sizeof(cursegmenttxid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CheckpointSignatureProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string blockPoolId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_blockpoolid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.CheckpointSignatureProto.blockPoolId");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 mostRecentCheckpointTxId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_mostrecentcheckpointtxid(&has_bits);
          mostrecentcheckpointtxid_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 curSegmentTxId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_cursegmenttxid(&has_bits);
          cursegmenttxid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_storageinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckpointSignatureProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.CheckpointSignatureProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string blockPoolId = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_blockpoolid().data(),
        static_cast<int>(this->_internal_blockpoolid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.CheckpointSignatureProto.blockPoolId");
    target = stream->WriteStringMaybeAliased(1, this->_internal_blockpoolid(),
                                             target);
  }

  // required uint64 mostRecentCheckpointTxId = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_mostrecentcheckpointtxid(), target);
  }

  // required uint64 curSegmentTxId = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_cursegmenttxid(), target);
  }

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::storageinfo(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.CheckpointSignatureProto)
  return target;
}

size_t CheckpointSignatureProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.CheckpointSignatureProto)
  size_t total_size = 0;

  if (_internal_has_blockpoolid()) {
    // required string blockPoolId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());
  }

  if (_internal_has_storageinfo()) {
    // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);
  }

  if (_internal_has_mostrecentcheckpointtxid()) {
    // required uint64 mostRecentCheckpointTxId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_mostrecentcheckpointtxid());
  }

  if (_internal_has_cursegmenttxid()) {
    // required uint64 curSegmentTxId = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_cursegmenttxid());
  }

  return total_size;
}
size_t CheckpointSignatureProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.CheckpointSignatureProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) ==
      0) {  // All required fields are present.
    // required string blockPoolId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());

    // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);

    // required uint64 mostRecentCheckpointTxId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_mostrecentcheckpointtxid());

    // required uint64 curSegmentTxId = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_cursegmenttxid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckpointSignatureProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.CheckpointSignatureProto)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckpointSignatureProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckpointSignatureProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.CheckpointSignatureProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.CheckpointSignatureProto)
    MergeFrom(*source);
  }
}

void CheckpointSignatureProto::MergeFrom(const CheckpointSignatureProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.CheckpointSignatureProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      blockpoolid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.blockpoolid_);
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_storageinfo()
          ->::Hdfs::Internal::StorageInfoProto::MergeFrom(
              from._internal_storageinfo());
    }
    if (cached_has_bits & 0x00000004u) {
      mostrecentcheckpointtxid_ = from.mostrecentcheckpointtxid_;
    }
    if (cached_has_bits & 0x00000008u) {
      cursegmenttxid_ = from.cursegmenttxid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CheckpointSignatureProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.CheckpointSignatureProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointSignatureProto::CopyFrom(const CheckpointSignatureProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.CheckpointSignatureProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointSignatureProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  if (_internal_has_storageinfo()) {
    if (!storageinfo_->IsInitialized()) return false;
  }
  return true;
}

void CheckpointSignatureProto::InternalSwap(CheckpointSignatureProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blockpoolid_.Swap(
      &other->blockpoolid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(storageinfo_, other->storageinfo_);
  swap(mostrecentcheckpointtxid_, other->mostrecentcheckpointtxid_);
  swap(cursegmenttxid_, other->cursegmenttxid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckpointSignatureProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void NamenodeCommandProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_NamenodeCommandProto_default_instance_._instance
      .get_mutable()
      ->checkpointcmd_ = const_cast<::Hdfs::Internal::CheckpointCommandProto*>(
      ::Hdfs::Internal::CheckpointCommandProto::internal_default_instance());
}
class NamenodeCommandProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NamenodeCommandProto>()._has_bits_);
  static void set_has_action(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_type(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static const ::Hdfs::Internal::CheckpointCommandProto& checkpointcmd(
      const NamenodeCommandProto* msg);
  static void set_has_checkpointcmd(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

const ::Hdfs::Internal::CheckpointCommandProto&
NamenodeCommandProto::_Internal::checkpointcmd(
    const NamenodeCommandProto* msg) {
  return *msg->checkpointcmd_;
}
NamenodeCommandProto::NamenodeCommandProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.NamenodeCommandProto)
}
NamenodeCommandProto::NamenodeCommandProto(const NamenodeCommandProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_checkpointcmd()) {
    checkpointcmd_ =
        new ::Hdfs::Internal::CheckpointCommandProto(*from.checkpointcmd_);
  } else {
    checkpointcmd_ = nullptr;
  }
  ::memcpy(&action_, &from.action_,
           static_cast<size_t>(reinterpret_cast<char*>(&type_) -
                               reinterpret_cast<char*>(&action_)) +
               sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.NamenodeCommandProto)
}

void NamenodeCommandProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_NamenodeCommandProto_hdfs_2eproto.base);
  ::memset(&checkpointcmd_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&type_) -
                               reinterpret_cast<char*>(&checkpointcmd_)) +
               sizeof(type_));
}

NamenodeCommandProto::~NamenodeCommandProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.NamenodeCommandProto)
  SharedDtor();
}

void NamenodeCommandProto::SharedDtor() {
  if (this != internal_default_instance()) delete checkpointcmd_;
}

void NamenodeCommandProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NamenodeCommandProto& NamenodeCommandProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_NamenodeCommandProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void NamenodeCommandProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.NamenodeCommandProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(checkpointcmd_ != nullptr);
    checkpointcmd_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&action_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&type_) -
                                 reinterpret_cast<char*>(&action_)) +
                 sizeof(type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NamenodeCommandProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_action(&has_bits);
          action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(
                  ::Hdfs::Internal::NamenodeCommandProto_Type_IsValid(val))) {
            _internal_set_type(
                static_cast<::Hdfs::Internal::NamenodeCommandProto_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(
                2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .Hdfs.Internal.CheckpointCommandProto checkpointCmd = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_checkpointcmd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NamenodeCommandProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.NamenodeCommandProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 action = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            1, this->_internal_action(), target);
  }

  // required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
            2, this->_internal_type(), target);
  }

  // optional .Hdfs.Internal.CheckpointCommandProto checkpointCmd = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::checkpointcmd(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.NamenodeCommandProto)
  return target;
}

size_t NamenodeCommandProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.NamenodeCommandProto)
  size_t total_size = 0;

  if (_internal_has_action()) {
    // required uint32 action = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_action());
  }

  if (_internal_has_type()) {
    // required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_type());
  }

  return total_size;
}
size_t NamenodeCommandProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.NamenodeCommandProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) ==
      0) {  // All required fields are present.
    // required uint32 action = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_action());

    // required .Hdfs.Internal.NamenodeCommandProto.Type type = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
                this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional .Hdfs.Internal.CheckpointCommandProto checkpointCmd = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *checkpointcmd_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamenodeCommandProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.NamenodeCommandProto)
  GOOGLE_DCHECK_NE(&from, this);
  const NamenodeCommandProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NamenodeCommandProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.NamenodeCommandProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.NamenodeCommandProto)
    MergeFrom(*source);
  }
}

void NamenodeCommandProto::MergeFrom(const NamenodeCommandProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.NamenodeCommandProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_checkpointcmd()
          ->::Hdfs::Internal::CheckpointCommandProto::MergeFrom(
              from._internal_checkpointcmd());
    }
    if (cached_has_bits & 0x00000002u) {
      action_ = from.action_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NamenodeCommandProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.NamenodeCommandProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamenodeCommandProto::CopyFrom(const NamenodeCommandProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.NamenodeCommandProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamenodeCommandProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  if (_internal_has_checkpointcmd()) {
    if (!checkpointcmd_->IsInitialized()) return false;
  }
  return true;
}

void NamenodeCommandProto::InternalSwap(NamenodeCommandProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(checkpointcmd_, other->checkpointcmd_);
  swap(action_, other->action_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamenodeCommandProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void CheckpointCommandProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_CheckpointCommandProto_default_instance_._instance
      .get_mutable()
      ->signature_ = const_cast<::Hdfs::Internal::CheckpointSignatureProto*>(
      ::Hdfs::Internal::CheckpointSignatureProto::internal_default_instance());
}
class CheckpointCommandProto::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckpointCommandProto>()._has_bits_);
  static const ::Hdfs::Internal::CheckpointSignatureProto& signature(
      const CheckpointCommandProto* msg);
  static void set_has_signature(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_needtoreturnimage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::Hdfs::Internal::CheckpointSignatureProto&
CheckpointCommandProto::_Internal::signature(
    const CheckpointCommandProto* msg) {
  return *msg->signature_;
}
CheckpointCommandProto::CheckpointCommandProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.CheckpointCommandProto)
}
CheckpointCommandProto::CheckpointCommandProto(
    const CheckpointCommandProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_signature()) {
    signature_ =
        new ::Hdfs::Internal::CheckpointSignatureProto(*from.signature_);
  } else {
    signature_ = nullptr;
  }
  needtoreturnimage_ = from.needtoreturnimage_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.CheckpointCommandProto)
}

void CheckpointCommandProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_CheckpointCommandProto_hdfs_2eproto.base);
  ::memset(&signature_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&needtoreturnimage_) -
                               reinterpret_cast<char*>(&signature_)) +
               sizeof(needtoreturnimage_));
}

CheckpointCommandProto::~CheckpointCommandProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.CheckpointCommandProto)
  SharedDtor();
}

void CheckpointCommandProto::SharedDtor() {
  if (this != internal_default_instance()) delete signature_;
}

void CheckpointCommandProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckpointCommandProto& CheckpointCommandProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_CheckpointCommandProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void CheckpointCommandProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.CheckpointCommandProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(signature_ != nullptr);
    signature_->Clear();
  }
  needtoreturnimage_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* CheckpointCommandProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_signature(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bool needToReturnImage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_needtoreturnimage(&has_bits);
          needtoreturnimage_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckpointCommandProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.CheckpointCommandProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::signature(this), target, stream);
  }

  // required bool needToReturnImage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            2, this->_internal_needtoreturnimage(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.CheckpointCommandProto)
  return target;
}

size_t CheckpointCommandProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.CheckpointCommandProto)
  size_t total_size = 0;

  if (_internal_has_signature()) {
    // required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *signature_);
  }

  if (_internal_has_needtoreturnimage()) {
    // required bool needToReturnImage = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t CheckpointCommandProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.CheckpointCommandProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) ==
      0) {  // All required fields are present.
    // required .Hdfs.Internal.CheckpointSignatureProto signature = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *signature_);

    // required bool needToReturnImage = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckpointCommandProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.CheckpointCommandProto)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckpointCommandProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckpointCommandProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.CheckpointCommandProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.CheckpointCommandProto)
    MergeFrom(*source);
  }
}

void CheckpointCommandProto::MergeFrom(const CheckpointCommandProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.CheckpointCommandProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_signature()
          ->::Hdfs::Internal::CheckpointSignatureProto::MergeFrom(
              from._internal_signature());
    }
    if (cached_has_bits & 0x00000002u) {
      needtoreturnimage_ = from.needtoreturnimage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void CheckpointCommandProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.CheckpointCommandProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckpointCommandProto::CopyFrom(const CheckpointCommandProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.CheckpointCommandProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckpointCommandProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (_internal_has_signature()) {
    if (!signature_->IsInitialized()) return false;
  }
  return true;
}

void CheckpointCommandProto::InternalSwap(CheckpointCommandProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(signature_, other->signature_);
  swap(needtoreturnimage_, other->needtoreturnimage_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckpointCommandProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void BlockProto::InitAsDefaultInstance() {}
class BlockProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BlockProto>()._has_bits_);
  static void set_has_blockid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_genstamp(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_numbytes(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
};

BlockProto::BlockProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.BlockProto)
}
BlockProto::BlockProto(const BlockProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&blockid_, &from.blockid_,
           static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                               reinterpret_cast<char*>(&blockid_)) +
               sizeof(numbytes_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.BlockProto)
}

void BlockProto::SharedCtor() {
  ::memset(&blockid_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                               reinterpret_cast<char*>(&blockid_)) +
               sizeof(numbytes_));
}

BlockProto::~BlockProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.BlockProto)
  SharedDtor();
}

void BlockProto::SharedDtor() {}

void BlockProto::SetCachedSize(int size) const { _cached_size_.Set(size); }
const BlockProto& BlockProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_BlockProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void BlockProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.BlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&blockid_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&numbytes_) -
                                 reinterpret_cast<char*>(&blockid_)) +
                 sizeof(numbytes_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BlockProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 blockId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_blockid(&has_bits);
          blockid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 genStamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_genstamp(&has_bits);
          genstamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 numBytes = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_numbytes(&has_bits);
          numbytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlockProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.BlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 blockId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_blockid(), target);
  }

  // required uint64 genStamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_genstamp(), target);
  }

  // optional uint64 numBytes = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_numbytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.BlockProto)
  return target;
}

size_t BlockProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.BlockProto)
  size_t total_size = 0;

  if (_internal_has_blockid()) {
    // required uint64 blockId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blockid());
  }

  if (_internal_has_genstamp()) {
    // required uint64 genStamp = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_genstamp());
  }

  return total_size;
}
size_t BlockProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.BlockProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) ==
      0) {  // All required fields are present.
    // required uint64 blockId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_blockid());

    // required uint64 genStamp = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_genstamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional uint64 numBytes = 3 [default = 0];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_numbytes());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlockProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.BlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  const BlockProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlockProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.BlockProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.BlockProto)
    MergeFrom(*source);
  }
}

void BlockProto::MergeFrom(const BlockProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.BlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      blockid_ = from.blockid_;
    }
    if (cached_has_bits & 0x00000002u) {
      genstamp_ = from.genstamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      numbytes_ = from.numbytes_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BlockProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.BlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockProto::CopyFrom(const BlockProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.BlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void BlockProto::InternalSwap(BlockProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(blockid_, other->blockid_);
  swap(genstamp_, other->genstamp_);
  swap(numbytes_, other->numbytes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void BlockWithLocationsProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_BlockWithLocationsProto_default_instance_._instance
      .get_mutable()
      ->block_ = const_cast<::Hdfs::Internal::BlockProto*>(
      ::Hdfs::Internal::BlockProto::internal_default_instance());
}
class BlockWithLocationsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BlockWithLocationsProto>()._has_bits_);
  static const ::Hdfs::Internal::BlockProto& block(
      const BlockWithLocationsProto* msg);
  static void set_has_block(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

const ::Hdfs::Internal::BlockProto& BlockWithLocationsProto::_Internal::block(
    const BlockWithLocationsProto* msg) {
  return *msg->block_;
}
BlockWithLocationsProto::BlockWithLocationsProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.BlockWithLocationsProto)
}
BlockWithLocationsProto::BlockWithLocationsProto(
    const BlockWithLocationsProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      datanodeuuids_(from.datanodeuuids_),
      storageuuids_(from.storageuuids_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_block()) {
    block_ = new ::Hdfs::Internal::BlockProto(*from.block_);
  } else {
    block_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.BlockWithLocationsProto)
}

void BlockWithLocationsProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_BlockWithLocationsProto_hdfs_2eproto.base);
  block_ = nullptr;
}

BlockWithLocationsProto::~BlockWithLocationsProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.BlockWithLocationsProto)
  SharedDtor();
}

void BlockWithLocationsProto::SharedDtor() {
  if (this != internal_default_instance()) delete block_;
}

void BlockWithLocationsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BlockWithLocationsProto& BlockWithLocationsProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_BlockWithLocationsProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void BlockWithLocationsProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.BlockWithLocationsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  datanodeuuids_.Clear();
  storageuuids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(block_ != nullptr);
    block_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BlockWithLocationsProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.BlockProto block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string datanodeUuids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_datanodeuuids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
                str, ptr, ctx);
#ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
                str, "Hdfs.Internal.BlockWithLocationsProto.datanodeUuids");
#endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string storageUuids = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_storageuuids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
                str, ptr, ctx);
#ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
                str, "Hdfs.Internal.BlockWithLocationsProto.storageUuids");
#endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlockWithLocationsProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.BlockWithLocationsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.BlockProto block = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::block(this), target, stream);
  }

  // repeated string datanodeUuids = 2;
  for (int i = 0, n = this->_internal_datanodeuuids_size(); i < n; i++) {
    const auto& s = this->_internal_datanodeuuids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        s.data(), static_cast<int>(s.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.BlockWithLocationsProto.datanodeUuids");
    target = stream->WriteString(2, s, target);
  }

  // repeated string storageUuids = 3;
  for (int i = 0, n = this->_internal_storageuuids_size(); i < n; i++) {
    const auto& s = this->_internal_storageuuids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        s.data(), static_cast<int>(s.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.BlockWithLocationsProto.storageUuids");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.BlockWithLocationsProto)
  return target;
}

size_t BlockWithLocationsProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.BlockWithLocationsProto)
  size_t total_size = 0;

  // required .Hdfs.Internal.BlockProto block = 1;
  if (_internal_has_block()) {
    total_size +=
        1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*block_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated string datanodeUuids = 2;
  total_size +=
      1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(datanodeuuids_.size());
  for (int i = 0, n = datanodeuuids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        datanodeuuids_.Get(i));
  }

  // repeated string storageUuids = 3;
  total_size +=
      1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(storageuuids_.size());
  for (int i = 0, n = storageuuids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        storageuuids_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlockWithLocationsProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.BlockWithLocationsProto)
  GOOGLE_DCHECK_NE(&from, this);
  const BlockWithLocationsProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlockWithLocationsProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.BlockWithLocationsProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.BlockWithLocationsProto)
    MergeFrom(*source);
  }
}

void BlockWithLocationsProto::MergeFrom(const BlockWithLocationsProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.BlockWithLocationsProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  datanodeuuids_.MergeFrom(from.datanodeuuids_);
  storageuuids_.MergeFrom(from.storageuuids_);
  if (from._internal_has_block()) {
    _internal_mutable_block()->::Hdfs::Internal::BlockProto::MergeFrom(
        from._internal_block());
  }
}

void BlockWithLocationsProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.BlockWithLocationsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockWithLocationsProto::CopyFrom(const BlockWithLocationsProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.BlockWithLocationsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockWithLocationsProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_block()) {
    if (!block_->IsInitialized()) return false;
  }
  return true;
}

void BlockWithLocationsProto::InternalSwap(BlockWithLocationsProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  datanodeuuids_.InternalSwap(&other->datanodeuuids_);
  storageuuids_.InternalSwap(&other->storageuuids_);
  swap(block_, other->block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockWithLocationsProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void BlocksWithLocationsProto::InitAsDefaultInstance() {}
class BlocksWithLocationsProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BlocksWithLocationsProto>()._has_bits_);
};

BlocksWithLocationsProto::BlocksWithLocationsProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.BlocksWithLocationsProto)
}
BlocksWithLocationsProto::BlocksWithLocationsProto(
    const BlocksWithLocationsProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      blocks_(from.blocks_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.BlocksWithLocationsProto)
}

void BlocksWithLocationsProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_BlocksWithLocationsProto_hdfs_2eproto.base);
}

BlocksWithLocationsProto::~BlocksWithLocationsProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.BlocksWithLocationsProto)
  SharedDtor();
}

void BlocksWithLocationsProto::SharedDtor() {}

void BlocksWithLocationsProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BlocksWithLocationsProto& BlocksWithLocationsProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_BlocksWithLocationsProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void BlocksWithLocationsProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.BlocksWithLocationsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  blocks_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BlocksWithLocationsProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Hdfs.Internal.BlockWithLocationsProto blocks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlocksWithLocationsProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.BlocksWithLocationsProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.BlockWithLocationsProto blocks = 1;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_blocks_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, this->_internal_blocks(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.BlocksWithLocationsProto)
  return target;
}

size_t BlocksWithLocationsProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.BlocksWithLocationsProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.BlockWithLocationsProto blocks = 1;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->blocks_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlocksWithLocationsProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.BlocksWithLocationsProto)
  GOOGLE_DCHECK_NE(&from, this);
  const BlocksWithLocationsProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlocksWithLocationsProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.BlocksWithLocationsProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.BlocksWithLocationsProto)
    MergeFrom(*source);
  }
}

void BlocksWithLocationsProto::MergeFrom(const BlocksWithLocationsProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.BlocksWithLocationsProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  blocks_.MergeFrom(from.blocks_);
}

void BlocksWithLocationsProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.BlocksWithLocationsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlocksWithLocationsProto::CopyFrom(const BlocksWithLocationsProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.BlocksWithLocationsProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlocksWithLocationsProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(blocks_))
    return false;
  return true;
}

void BlocksWithLocationsProto::InternalSwap(BlocksWithLocationsProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blocks_.InternalSwap(&other->blocks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlocksWithLocationsProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void RemoteEditLogProto::InitAsDefaultInstance() {}
class RemoteEditLogProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RemoteEditLogProto>()._has_bits_);
  static void set_has_starttxid(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_endtxid(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_isinprogress(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
};

RemoteEditLogProto::RemoteEditLogProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.RemoteEditLogProto)
}
RemoteEditLogProto::RemoteEditLogProto(const RemoteEditLogProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&starttxid_, &from.starttxid_,
           static_cast<size_t>(reinterpret_cast<char*>(&isinprogress_) -
                               reinterpret_cast<char*>(&starttxid_)) +
               sizeof(isinprogress_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.RemoteEditLogProto)
}

void RemoteEditLogProto::SharedCtor() {
  ::memset(&starttxid_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&isinprogress_) -
                               reinterpret_cast<char*>(&starttxid_)) +
               sizeof(isinprogress_));
}

RemoteEditLogProto::~RemoteEditLogProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.RemoteEditLogProto)
  SharedDtor();
}

void RemoteEditLogProto::SharedDtor() {}

void RemoteEditLogProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RemoteEditLogProto& RemoteEditLogProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_RemoteEditLogProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void RemoteEditLogProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.RemoteEditLogProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&starttxid_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&isinprogress_) -
                                 reinterpret_cast<char*>(&starttxid_)) +
                 sizeof(isinprogress_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RemoteEditLogProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 startTxId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_starttxid(&has_bits);
          starttxid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 endTxId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_endtxid(&has_bits);
          endtxid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool isInProgress = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_isinprogress(&has_bits);
          isinprogress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RemoteEditLogProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.RemoteEditLogProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 startTxId = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_starttxid(), target);
  }

  // required uint64 endTxId = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_endtxid(), target);
  }

  // optional bool isInProgress = 3 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            3, this->_internal_isinprogress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.RemoteEditLogProto)
  return target;
}

size_t RemoteEditLogProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.RemoteEditLogProto)
  size_t total_size = 0;

  if (_internal_has_starttxid()) {
    // required uint64 startTxId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_starttxid());
  }

  if (_internal_has_endtxid()) {
    // required uint64 endTxId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_endtxid());
  }

  return total_size;
}
size_t RemoteEditLogProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.RemoteEditLogProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) ==
      0) {  // All required fields are present.
    // required uint64 startTxId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_starttxid());

    // required uint64 endTxId = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_endtxid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional bool isInProgress = 3 [default = false];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteEditLogProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.RemoteEditLogProto)
  GOOGLE_DCHECK_NE(&from, this);
  const RemoteEditLogProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RemoteEditLogProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.RemoteEditLogProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.RemoteEditLogProto)
    MergeFrom(*source);
  }
}

void RemoteEditLogProto::MergeFrom(const RemoteEditLogProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.RemoteEditLogProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      starttxid_ = from.starttxid_;
    }
    if (cached_has_bits & 0x00000002u) {
      endtxid_ = from.endtxid_;
    }
    if (cached_has_bits & 0x00000004u) {
      isinprogress_ = from.isinprogress_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RemoteEditLogProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.RemoteEditLogProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteEditLogProto::CopyFrom(const RemoteEditLogProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.RemoteEditLogProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteEditLogProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void RemoteEditLogProto::InternalSwap(RemoteEditLogProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(starttxid_, other->starttxid_);
  swap(endtxid_, other->endtxid_);
  swap(isinprogress_, other->isinprogress_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoteEditLogProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void RemoteEditLogManifestProto::InitAsDefaultInstance() {}
class RemoteEditLogManifestProto::_Internal {
 public:
  using HasBits =
      decltype(std::declval<RemoteEditLogManifestProto>()._has_bits_);
};

RemoteEditLogManifestProto::RemoteEditLogManifestProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.RemoteEditLogManifestProto)
}
RemoteEditLogManifestProto::RemoteEditLogManifestProto(
    const RemoteEditLogManifestProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      logs_(from.logs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.RemoteEditLogManifestProto)
}

void RemoteEditLogManifestProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_RemoteEditLogManifestProto_hdfs_2eproto.base);
}

RemoteEditLogManifestProto::~RemoteEditLogManifestProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.RemoteEditLogManifestProto)
  SharedDtor();
}

void RemoteEditLogManifestProto::SharedDtor() {}

void RemoteEditLogManifestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RemoteEditLogManifestProto&
RemoteEditLogManifestProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_RemoteEditLogManifestProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void RemoteEditLogManifestProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.RemoteEditLogManifestProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  logs_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RemoteEditLogManifestProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .Hdfs.Internal.RemoteEditLogProto logs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RemoteEditLogManifestProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.RemoteEditLogManifestProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.RemoteEditLogProto logs = 1;
  for (unsigned int i = 0,
                    n = static_cast<unsigned int>(this->_internal_logs_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, this->_internal_logs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.RemoteEditLogManifestProto)
  return target;
}

size_t RemoteEditLogManifestProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.RemoteEditLogManifestProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.RemoteEditLogProto logs = 1;
  total_size += 1UL * this->_internal_logs_size();
  for (const auto& msg : this->logs_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RemoteEditLogManifestProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.RemoteEditLogManifestProto)
  GOOGLE_DCHECK_NE(&from, this);
  const RemoteEditLogManifestProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<
          RemoteEditLogManifestProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.RemoteEditLogManifestProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.RemoteEditLogManifestProto)
    MergeFrom(*source);
  }
}

void RemoteEditLogManifestProto::MergeFrom(
    const RemoteEditLogManifestProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.RemoteEditLogManifestProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  logs_.MergeFrom(from.logs_);
}

void RemoteEditLogManifestProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.RemoteEditLogManifestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteEditLogManifestProto::CopyFrom(
    const RemoteEditLogManifestProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.RemoteEditLogManifestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteEditLogManifestProto::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(logs_))
    return false;
  return true;
}

void RemoteEditLogManifestProto::InternalSwap(
    RemoteEditLogManifestProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  logs_.InternalSwap(&other->logs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RemoteEditLogManifestProto::GetMetadata()
    const {
  return GetMetadataStatic();
}

// ===================================================================

void NamespaceInfoProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_NamespaceInfoProto_default_instance_._instance
      .get_mutable()
      ->storageinfo_ = const_cast<::Hdfs::Internal::StorageInfoProto*>(
      ::Hdfs::Internal::StorageInfoProto::internal_default_instance());
}
class NamespaceInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespaceInfoProto>()._has_bits_);
  static void set_has_buildversion(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_unused(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
  static void set_has_blockpoolid(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static const ::Hdfs::Internal::StorageInfoProto& storageinfo(
      const NamespaceInfoProto* msg);
  static void set_has_storageinfo(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_softwareversion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::Hdfs::Internal::StorageInfoProto&
NamespaceInfoProto::_Internal::storageinfo(const NamespaceInfoProto* msg) {
  return *msg->storageinfo_;
}
NamespaceInfoProto::NamespaceInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.NamespaceInfoProto)
}
NamespaceInfoProto::NamespaceInfoProto(const NamespaceInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  buildversion_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_buildversion()) {
    buildversion_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.buildversion_);
  }
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blockpoolid()) {
    blockpoolid_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.blockpoolid_);
  }
  softwareversion_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_softwareversion()) {
    softwareversion_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.softwareversion_);
  }
  if (from._internal_has_storageinfo()) {
    storageinfo_ = new ::Hdfs::Internal::StorageInfoProto(*from.storageinfo_);
  } else {
    storageinfo_ = nullptr;
  }
  unused_ = from.unused_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.NamespaceInfoProto)
}

void NamespaceInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_NamespaceInfoProto_hdfs_2eproto.base);
  buildversion_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blockpoolid_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  softwareversion_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&storageinfo_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&unused_) -
                               reinterpret_cast<char*>(&storageinfo_)) +
               sizeof(unused_));
}

NamespaceInfoProto::~NamespaceInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.NamespaceInfoProto)
  SharedDtor();
}

void NamespaceInfoProto::SharedDtor() {
  buildversion_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blockpoolid_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  softwareversion_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete storageinfo_;
}

void NamespaceInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NamespaceInfoProto& NamespaceInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_NamespaceInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void NamespaceInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.NamespaceInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      buildversion_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      blockpoolid_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      softwareversion_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(storageinfo_ != nullptr);
      storageinfo_->Clear();
    }
  }
  unused_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* NamespaceInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string buildVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_buildversion();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.NamespaceInfoProto.buildVersion");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 unused = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_unused(&has_bits);
          unused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string blockPoolID = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_blockpoolid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.NamespaceInfoProto.blockPoolID");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_storageinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string softwareVersion = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_softwareversion();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.NamespaceInfoProto.softwareVersion");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NamespaceInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.NamespaceInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string buildVersion = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_buildversion().data(),
        static_cast<int>(this->_internal_buildversion().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.NamespaceInfoProto.buildVersion");
    target = stream->WriteStringMaybeAliased(1, this->_internal_buildversion(),
                                             target);
  }

  // required uint32 unused = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            2, this->_internal_unused(), target);
  }

  // required string blockPoolID = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_blockpoolid().data(),
        static_cast<int>(this->_internal_blockpoolid().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.NamespaceInfoProto.blockPoolID");
    target = stream->WriteStringMaybeAliased(3, this->_internal_blockpoolid(),
                                             target);
  }

  // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::storageinfo(this), target, stream);
  }

  // required string softwareVersion = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_softwareversion().data(),
        static_cast<int>(this->_internal_softwareversion().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.NamespaceInfoProto.softwareVersion");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_softwareversion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.NamespaceInfoProto)
  return target;
}

size_t NamespaceInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.NamespaceInfoProto)
  size_t total_size = 0;

  if (_internal_has_buildversion()) {
    // required string buildVersion = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_buildversion());
  }

  if (_internal_has_blockpoolid()) {
    // required string blockPoolID = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());
  }

  if (_internal_has_softwareversion()) {
    // required string softwareVersion = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_softwareversion());
  }

  if (_internal_has_storageinfo()) {
    // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);
  }

  if (_internal_has_unused()) {
    // required uint32 unused = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_unused());
  }

  return total_size;
}
size_t NamespaceInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.NamespaceInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) ==
      0) {  // All required fields are present.
    // required string buildVersion = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_buildversion());

    // required string blockPoolID = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_blockpoolid());

    // required string softwareVersion = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_softwareversion());

    // required .Hdfs.Internal.StorageInfoProto storageInfo = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *storageinfo_);

    // required uint32 unused = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_unused());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamespaceInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.NamespaceInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const NamespaceInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NamespaceInfoProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.NamespaceInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.NamespaceInfoProto)
    MergeFrom(*source);
  }
}

void NamespaceInfoProto::MergeFrom(const NamespaceInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.NamespaceInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      buildversion_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.buildversion_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      blockpoolid_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.blockpoolid_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      softwareversion_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.softwareversion_);
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_storageinfo()
          ->::Hdfs::Internal::StorageInfoProto::MergeFrom(
              from._internal_storageinfo());
    }
    if (cached_has_bits & 0x00000010u) {
      unused_ = from.unused_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NamespaceInfoProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.NamespaceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamespaceInfoProto::CopyFrom(const NamespaceInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.NamespaceInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespaceInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  if (_internal_has_storageinfo()) {
    if (!storageinfo_->IsInitialized()) return false;
  }
  return true;
}

void NamespaceInfoProto::InternalSwap(NamespaceInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  buildversion_.Swap(
      &other->buildversion_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  blockpoolid_.Swap(
      &other->blockpoolid_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  softwareversion_.Swap(
      &other->softwareversion_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(storageinfo_, other->storageinfo_);
  swap(unused_, other->unused_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespaceInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void BlockKeyProto::InitAsDefaultInstance() {}
class BlockKeyProto::_Internal {
 public:
  using HasBits = decltype(std::declval<BlockKeyProto>()._has_bits_);
  static void set_has_keyid(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_expirydate(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static void set_has_keybytes(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

BlockKeyProto::BlockKeyProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.BlockKeyProto)
}
BlockKeyProto::BlockKeyProto(const BlockKeyProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  keybytes_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_keybytes()) {
    keybytes_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.keybytes_);
  }
  ::memcpy(&expirydate_, &from.expirydate_,
           static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                               reinterpret_cast<char*>(&expirydate_)) +
               sizeof(keyid_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.BlockKeyProto)
}

void BlockKeyProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_BlockKeyProto_hdfs_2eproto.base);
  keybytes_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&expirydate_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                               reinterpret_cast<char*>(&expirydate_)) +
               sizeof(keyid_));
}

BlockKeyProto::~BlockKeyProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.BlockKeyProto)
  SharedDtor();
}

void BlockKeyProto::SharedDtor() {
  keybytes_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BlockKeyProto::SetCachedSize(int size) const { _cached_size_.Set(size); }
const BlockKeyProto& BlockKeyProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_BlockKeyProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void BlockKeyProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.BlockKeyProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    keybytes_.ClearNonDefaultToEmptyNoArena();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&expirydate_, 0,
             static_cast<size_t>(reinterpret_cast<char*>(&keyid_) -
                                 reinterpret_cast<char*>(&expirydate_)) +
                 sizeof(keyid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* BlockKeyProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 keyId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_keyid(&has_bits);
          keyid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 expiryDate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_expirydate(&has_bits);
          expirydate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes keyBytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_keybytes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BlockKeyProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.BlockKeyProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 keyId = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(
            1, this->_internal_keyid(), target);
  }

  // required uint64 expiryDate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_expirydate(), target);
  }

  // optional bytes keyBytes = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
        stream->WriteBytesMaybeAliased(3, this->_internal_keybytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.BlockKeyProto)
  return target;
}

size_t BlockKeyProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.BlockKeyProto)
  size_t total_size = 0;

  if (_internal_has_expirydate()) {
    // required uint64 expiryDate = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_expirydate());
  }

  if (_internal_has_keyid()) {
    // required uint32 keyId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_keyid());
  }

  return total_size;
}
size_t BlockKeyProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.BlockKeyProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) ==
      0) {  // All required fields are present.
    // required uint64 expiryDate = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_expirydate());

    // required uint32 keyId = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
                this->_internal_keyid());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // optional bytes keyBytes = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
                this->_internal_keybytes());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BlockKeyProto::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.BlockKeyProto)
  GOOGLE_DCHECK_NE(&from, this);
  const BlockKeyProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BlockKeyProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.BlockKeyProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.BlockKeyProto)
    MergeFrom(*source);
  }
}

void BlockKeyProto::MergeFrom(const BlockKeyProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.BlockKeyProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      keybytes_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.keybytes_);
    }
    if (cached_has_bits & 0x00000002u) {
      expirydate_ = from.expirydate_;
    }
    if (cached_has_bits & 0x00000004u) {
      keyid_ = from.keyid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BlockKeyProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.BlockKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BlockKeyProto::CopyFrom(const BlockKeyProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.BlockKeyProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockKeyProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;
  return true;
}

void BlockKeyProto::InternalSwap(BlockKeyProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  keybytes_.Swap(
      &other->keybytes_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(expirydate_, other->expirydate_);
  swap(keyid_, other->keyid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockKeyProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void ExportedBlockKeysProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_ExportedBlockKeysProto_default_instance_._instance
      .get_mutable()
      ->currentkey_ = const_cast<::Hdfs::Internal::BlockKeyProto*>(
      ::Hdfs::Internal::BlockKeyProto::internal_default_instance());
}
class ExportedBlockKeysProto::_Internal {
 public:
  using HasBits = decltype(std::declval<ExportedBlockKeysProto>()._has_bits_);
  static void set_has_isblocktokenenabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_keyupdateinterval(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tokenlifetime(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static const ::Hdfs::Internal::BlockKeyProto& currentkey(
      const ExportedBlockKeysProto* msg);
  static void set_has_currentkey(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

const ::Hdfs::Internal::BlockKeyProto&
ExportedBlockKeysProto::_Internal::currentkey(
    const ExportedBlockKeysProto* msg) {
  return *msg->currentkey_;
}
ExportedBlockKeysProto::ExportedBlockKeysProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.ExportedBlockKeysProto)
}
ExportedBlockKeysProto::ExportedBlockKeysProto(
    const ExportedBlockKeysProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      allkeys_(from.allkeys_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_currentkey()) {
    currentkey_ = new ::Hdfs::Internal::BlockKeyProto(*from.currentkey_);
  } else {
    currentkey_ = nullptr;
  }
  ::memcpy(&keyupdateinterval_, &from.keyupdateinterval_,
           static_cast<size_t>(reinterpret_cast<char*>(&isblocktokenenabled_) -
                               reinterpret_cast<char*>(&keyupdateinterval_)) +
               sizeof(isblocktokenenabled_));
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.ExportedBlockKeysProto)
}

void ExportedBlockKeysProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_ExportedBlockKeysProto_hdfs_2eproto.base);
  ::memset(&currentkey_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&isblocktokenenabled_) -
                               reinterpret_cast<char*>(&currentkey_)) +
               sizeof(isblocktokenenabled_));
}

ExportedBlockKeysProto::~ExportedBlockKeysProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.ExportedBlockKeysProto)
  SharedDtor();
}

void ExportedBlockKeysProto::SharedDtor() {
  if (this != internal_default_instance()) delete currentkey_;
}

void ExportedBlockKeysProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ExportedBlockKeysProto& ExportedBlockKeysProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_ExportedBlockKeysProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void ExportedBlockKeysProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.ExportedBlockKeysProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  allkeys_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(currentkey_ != nullptr);
    currentkey_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(
        &keyupdateinterval_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&isblocktokenenabled_) -
                            reinterpret_cast<char*>(&keyupdateinterval_)) +
            sizeof(isblocktokenenabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* ExportedBlockKeysProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool isBlockTokenEnabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_isblocktokenenabled(&has_bits);
          isblocktokenenabled_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 keyUpdateInterval = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_keyupdateinterval(&has_bits);
          keyupdateinterval_ =
              ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint64 tokenLifeTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_tokenlifetime(&has_bits);
          tokenlifetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.BlockKeyProto currentKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_currentkey(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Hdfs.Internal.BlockKeyProto allKeys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allkeys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExportedBlockKeysProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.ExportedBlockKeysProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool isBlockTokenEnabled = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(
            1, this->_internal_isblocktokenenabled(), target);
  }

  // required uint64 keyUpdateInterval = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            2, this->_internal_keyupdateinterval(), target);
  }

  // required uint64 tokenLifeTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            3, this->_internal_tokenlifetime(), target);
  }

  // required .Hdfs.Internal.BlockKeyProto currentKey = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::currentkey(this), target, stream);
  }

  // repeated .Hdfs.Internal.BlockKeyProto allKeys = 5;
  for (unsigned int i = 0, n = static_cast<unsigned int>(
                               this->_internal_allkeys_size());
       i < n; i++) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, this->_internal_allkeys(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.ExportedBlockKeysProto)
  return target;
}

size_t ExportedBlockKeysProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.ExportedBlockKeysProto)
  size_t total_size = 0;

  if (_internal_has_currentkey()) {
    // required .Hdfs.Internal.BlockKeyProto currentKey = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *currentkey_);
  }

  if (_internal_has_keyupdateinterval()) {
    // required uint64 keyUpdateInterval = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_keyupdateinterval());
  }

  if (_internal_has_tokenlifetime()) {
    // required uint64 tokenLifeTime = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_tokenlifetime());
  }

  if (_internal_has_isblocktokenenabled()) {
    // required bool isBlockTokenEnabled = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ExportedBlockKeysProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.ExportedBlockKeysProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) ==
      0) {  // All required fields are present.
    // required .Hdfs.Internal.BlockKeyProto currentKey = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *currentkey_);

    // required uint64 keyUpdateInterval = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_keyupdateinterval());

    // required uint64 tokenLifeTime = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_tokenlifetime());

    // required bool isBlockTokenEnabled = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  // repeated .Hdfs.Internal.BlockKeyProto allKeys = 5;
  total_size += 1UL * this->_internal_allkeys_size();
  for (const auto& msg : this->allkeys_) {
    total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExportedBlockKeysProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.ExportedBlockKeysProto)
  GOOGLE_DCHECK_NE(&from, this);
  const ExportedBlockKeysProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExportedBlockKeysProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.ExportedBlockKeysProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.ExportedBlockKeysProto)
    MergeFrom(*source);
  }
}

void ExportedBlockKeysProto::MergeFrom(const ExportedBlockKeysProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.ExportedBlockKeysProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  allkeys_.MergeFrom(from.allkeys_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_currentkey()
          ->::Hdfs::Internal::BlockKeyProto::MergeFrom(
              from._internal_currentkey());
    }
    if (cached_has_bits & 0x00000002u) {
      keyupdateinterval_ = from.keyupdateinterval_;
    }
    if (cached_has_bits & 0x00000004u) {
      tokenlifetime_ = from.tokenlifetime_;
    }
    if (cached_has_bits & 0x00000008u) {
      isblocktokenenabled_ = from.isblocktokenenabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ExportedBlockKeysProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.ExportedBlockKeysProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExportedBlockKeysProto::CopyFrom(const ExportedBlockKeysProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.ExportedBlockKeysProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExportedBlockKeysProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(allkeys_))
    return false;
  if (_internal_has_currentkey()) {
    if (!currentkey_->IsInitialized()) return false;
  }
  return true;
}

void ExportedBlockKeysProto::InternalSwap(ExportedBlockKeysProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allkeys_.InternalSwap(&other->allkeys_);
  swap(currentkey_, other->currentkey_);
  swap(keyupdateinterval_, other->keyupdateinterval_);
  swap(tokenlifetime_, other->tokenlifetime_);
  swap(isblocktokenenabled_, other->isblocktokenenabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ExportedBlockKeysProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void RecoveringBlockProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_RecoveringBlockProto_default_instance_._instance
      .get_mutable()
      ->block_ = const_cast<::Hdfs::Internal::LocatedBlockProto*>(
      ::Hdfs::Internal::LocatedBlockProto::internal_default_instance());
}
class RecoveringBlockProto::_Internal {
 public:
  using HasBits = decltype(std::declval<RecoveringBlockProto>()._has_bits_);
  static void set_has_newgenstamp(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static const ::Hdfs::Internal::LocatedBlockProto& block(
      const RecoveringBlockProto* msg);
  static void set_has_block(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

const ::Hdfs::Internal::LocatedBlockProto&
RecoveringBlockProto::_Internal::block(const RecoveringBlockProto* msg) {
  return *msg->block_;
}
RecoveringBlockProto::RecoveringBlockProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.RecoveringBlockProto)
}
RecoveringBlockProto::RecoveringBlockProto(const RecoveringBlockProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_block()) {
    block_ = new ::Hdfs::Internal::LocatedBlockProto(*from.block_);
  } else {
    block_ = nullptr;
  }
  newgenstamp_ = from.newgenstamp_;
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.RecoveringBlockProto)
}

void RecoveringBlockProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_RecoveringBlockProto_hdfs_2eproto.base);
  ::memset(&block_, 0,
           static_cast<size_t>(reinterpret_cast<char*>(&newgenstamp_) -
                               reinterpret_cast<char*>(&block_)) +
               sizeof(newgenstamp_));
}

RecoveringBlockProto::~RecoveringBlockProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.RecoveringBlockProto)
  SharedDtor();
}

void RecoveringBlockProto::SharedDtor() {
  if (this != internal_default_instance()) delete block_;
}

void RecoveringBlockProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RecoveringBlockProto& RecoveringBlockProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_RecoveringBlockProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void RecoveringBlockProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.RecoveringBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(block_ != nullptr);
    block_->Clear();
  }
  newgenstamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* RecoveringBlockProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 newGenStamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_newgenstamp(&has_bits);
          newgenstamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.LocatedBlockProto block = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RecoveringBlockProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.RecoveringBlockProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 newGenStamp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(
            1, this->_internal_newgenstamp(), target);
  }

  // required .Hdfs.Internal.LocatedBlockProto block = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::block(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.RecoveringBlockProto)
  return target;
}

size_t RecoveringBlockProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.RecoveringBlockProto)
  size_t total_size = 0;

  if (_internal_has_block()) {
    // required .Hdfs.Internal.LocatedBlockProto block = 2;
    total_size +=
        1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*block_);
  }

  if (_internal_has_newgenstamp()) {
    // required uint64 newGenStamp = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_newgenstamp());
  }

  return total_size;
}
size_t RecoveringBlockProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.RecoveringBlockProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) ==
      0) {  // All required fields are present.
    // required .Hdfs.Internal.LocatedBlockProto block = 2;
    total_size +=
        1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*block_);

    // required uint64 newGenStamp = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                this->_internal_newgenstamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RecoveringBlockProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.RecoveringBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  const RecoveringBlockProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RecoveringBlockProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.RecoveringBlockProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.RecoveringBlockProto)
    MergeFrom(*source);
  }
}

void RecoveringBlockProto::MergeFrom(const RecoveringBlockProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.RecoveringBlockProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_block()->::Hdfs::Internal::LocatedBlockProto::MergeFrom(
          from._internal_block());
    }
    if (cached_has_bits & 0x00000002u) {
      newgenstamp_ = from.newgenstamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RecoveringBlockProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.RecoveringBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecoveringBlockProto::CopyFrom(const RecoveringBlockProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.RecoveringBlockProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveringBlockProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (_internal_has_block()) {
    if (!block_->IsInitialized()) return false;
  }
  return true;
}

void RecoveringBlockProto::InternalSwap(RecoveringBlockProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(block_, other->block_);
  swap(newgenstamp_, other->newgenstamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RecoveringBlockProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void VersionRequestProto::InitAsDefaultInstance() {}
class VersionRequestProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VersionRequestProto>()._has_bits_);
};

VersionRequestProto::VersionRequestProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.VersionRequestProto)
}
VersionRequestProto::VersionRequestProto(const VersionRequestProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.VersionRequestProto)
}

void VersionRequestProto::SharedCtor() {}

VersionRequestProto::~VersionRequestProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.VersionRequestProto)
  SharedDtor();
}

void VersionRequestProto::SharedDtor() {}

void VersionRequestProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VersionRequestProto& VersionRequestProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_VersionRequestProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void VersionRequestProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.VersionRequestProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* VersionRequestProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    if ((tag & 7) == 4 || tag == 0) {
      ctx->SetLastTag(tag);
      goto success;
    }
    ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
    CHK_(ptr != nullptr);
    continue;
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VersionRequestProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.VersionRequestProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.VersionRequestProto)
  return target;
}

size_t VersionRequestProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.VersionRequestProto)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VersionRequestProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.VersionRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  const VersionRequestProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<VersionRequestProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.VersionRequestProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.VersionRequestProto)
    MergeFrom(*source);
  }
}

void VersionRequestProto::MergeFrom(const VersionRequestProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.VersionRequestProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;
}

void VersionRequestProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.VersionRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionRequestProto::CopyFrom(const VersionRequestProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.VersionRequestProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionRequestProto::IsInitialized() const { return true; }

void VersionRequestProto::InternalSwap(VersionRequestProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata VersionRequestProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void VersionResponseProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_VersionResponseProto_default_instance_._instance
      .get_mutable()
      ->info_ = const_cast<::Hdfs::Internal::NamespaceInfoProto*>(
      ::Hdfs::Internal::NamespaceInfoProto::internal_default_instance());
}
class VersionResponseProto::_Internal {
 public:
  using HasBits = decltype(std::declval<VersionResponseProto>()._has_bits_);
  static const ::Hdfs::Internal::NamespaceInfoProto& info(
      const VersionResponseProto* msg);
  static void set_has_info(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
};

const ::Hdfs::Internal::NamespaceInfoProto&
VersionResponseProto::_Internal::info(const VersionResponseProto* msg) {
  return *msg->info_;
}
VersionResponseProto::VersionResponseProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.VersionResponseProto)
}
VersionResponseProto::VersionResponseProto(const VersionResponseProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::Hdfs::Internal::NamespaceInfoProto(*from.info_);
  } else {
    info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.VersionResponseProto)
}

void VersionResponseProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_VersionResponseProto_hdfs_2eproto.base);
  info_ = nullptr;
}

VersionResponseProto::~VersionResponseProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.VersionResponseProto)
  SharedDtor();
}

void VersionResponseProto::SharedDtor() {
  if (this != internal_default_instance()) delete info_;
}

void VersionResponseProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const VersionResponseProto& VersionResponseProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_VersionResponseProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void VersionResponseProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.VersionResponseProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* VersionResponseProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Hdfs.Internal.NamespaceInfoProto info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VersionResponseProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.VersionResponseProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Hdfs.Internal.NamespaceInfoProto info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.VersionResponseProto)
  return target;
}

size_t VersionResponseProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.VersionResponseProto)
  size_t total_size = 0;

  // required .Hdfs.Internal.NamespaceInfoProto info = 1;
  if (_internal_has_info()) {
    total_size +=
        1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*info_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VersionResponseProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.VersionResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  const VersionResponseProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<VersionResponseProto>(
          &from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.VersionResponseProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.VersionResponseProto)
    MergeFrom(*source);
  }
}

void VersionResponseProto::MergeFrom(const VersionResponseProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.VersionResponseProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  if (from._internal_has_info()) {
    _internal_mutable_info()->::Hdfs::Internal::NamespaceInfoProto::MergeFrom(
        from._internal_info());
  }
}

void VersionResponseProto::CopyFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.VersionResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionResponseProto::CopyFrom(const VersionResponseProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.VersionResponseProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionResponseProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (_internal_has_info()) {
    if (!info_->IsInitialized()) return false;
  }
  return true;
}

void VersionResponseProto::InternalSwap(VersionResponseProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(info_, other->info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VersionResponseProto::GetMetadata() const {
  return GetMetadataStatic();
}

// ===================================================================

void SnapshotInfoProto::InitAsDefaultInstance() {
  ::Hdfs::Internal::_SnapshotInfoProto_default_instance_._instance
      .get_mutable()
      ->permission_ = const_cast<::Hdfs::Internal::FsPermissionProto*>(
      ::Hdfs::Internal::FsPermissionProto::internal_default_instance());
}
class SnapshotInfoProto::_Internal {
 public:
  using HasBits = decltype(std::declval<SnapshotInfoProto>()._has_bits_);
  static void set_has_snapshotname(HasBits* has_bits) { (*has_bits)[0] |= 1u; }
  static void set_has_snapshotroot(HasBits* has_bits) { (*has_bits)[0] |= 2u; }
  static const ::Hdfs::Internal::FsPermissionProto& permission(
      const SnapshotInfoProto* msg);
  static void set_has_permission(HasBits* has_bits) { (*has_bits)[0] |= 32u; }
  static void set_has_owner(HasBits* has_bits) { (*has_bits)[0] |= 4u; }
  static void set_has_group(HasBits* has_bits) { (*has_bits)[0] |= 8u; }
  static void set_has_createtime(HasBits* has_bits) { (*has_bits)[0] |= 16u; }
};

const ::Hdfs::Internal::FsPermissionProto&
SnapshotInfoProto::_Internal::permission(const SnapshotInfoProto* msg) {
  return *msg->permission_;
}
SnapshotInfoProto::SnapshotInfoProto()
    : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Hdfs.Internal.SnapshotInfoProto)
}
SnapshotInfoProto::SnapshotInfoProto(const SnapshotInfoProto& from)
    : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  snapshotname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_snapshotname()) {
    snapshotname_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.snapshotname_);
  }
  snapshotroot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_snapshotroot()) {
    snapshotroot_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.snapshotroot_);
  }
  owner_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_owner()) {
    owner_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.owner_);
  }
  group_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_group()) {
    group_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.group_);
  }
  createtime_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_createtime()) {
    createtime_.AssignWithDefault(
        &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
        from.createtime_);
  }
  if (from._internal_has_permission()) {
    permission_ = new ::Hdfs::Internal::FsPermissionProto(*from.permission_);
  } else {
    permission_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Hdfs.Internal.SnapshotInfoProto)
}

void SnapshotInfoProto::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &scc_info_SnapshotInfoProto_hdfs_2eproto.base);
  snapshotname_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  snapshotroot_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  owner_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  createtime_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  permission_ = nullptr;
}

SnapshotInfoProto::~SnapshotInfoProto() {
  // @@protoc_insertion_point(destructor:Hdfs.Internal.SnapshotInfoProto)
  SharedDtor();
}

void SnapshotInfoProto::SharedDtor() {
  snapshotname_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  snapshotroot_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  owner_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  createtime_.DestroyNoArena(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete permission_;
}

void SnapshotInfoProto::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SnapshotInfoProto& SnapshotInfoProto::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(
      &::scc_info_SnapshotInfoProto_hdfs_2eproto.base);
  return *internal_default_instance();
}

void SnapshotInfoProto::Clear() {
  // @@protoc_insertion_point(message_clear_start:Hdfs.Internal.SnapshotInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      snapshotname_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      snapshotroot_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      owner_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      group_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      createtime_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(permission_ != nullptr);
      permission_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* SnapshotInfoProto::_InternalParse(
    const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) \
  if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string snapshotName = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_snapshotname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotInfoProto.snapshotName");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string snapshotRoot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_snapshotroot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotInfoProto.snapshotRoot");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .Hdfs.Internal.FsPermissionProto permission = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_permission(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string owner = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_owner();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotInfoProto.owner");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string group = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_group();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotInfoProto.group");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string createTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(
                static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_createtime();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(
              str, ptr, ctx);
#ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(
              str, "Hdfs.Internal.SnapshotInfoProto.createTime");
#endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }    // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SnapshotInfoProto::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target,
    ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Hdfs.Internal.SnapshotInfoProto)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string snapshotName = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_snapshotname().data(),
        static_cast<int>(this->_internal_snapshotname().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotInfoProto.snapshotName");
    target = stream->WriteStringMaybeAliased(1, this->_internal_snapshotname(),
                                             target);
  }

  // required string snapshotRoot = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_snapshotroot().data(),
        static_cast<int>(this->_internal_snapshotroot().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotInfoProto.snapshotRoot");
    target = stream->WriteStringMaybeAliased(2, this->_internal_snapshotroot(),
                                             target);
  }

  // required .Hdfs.Internal.FsPermissionProto permission = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::permission(this), target, stream);
  }

  // required string owner = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_owner().data(),
        static_cast<int>(this->_internal_owner().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotInfoProto.owner");
    target =
        stream->WriteStringMaybeAliased(4, this->_internal_owner(), target);
  }

  // required string group = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_group().data(),
        static_cast<int>(this->_internal_group().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotInfoProto.group");
    target =
        stream->WriteStringMaybeAliased(5, this->_internal_group(), target);
  }

  // required string createTime = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_createtime().data(),
        static_cast<int>(this->_internal_createtime().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "Hdfs.Internal.SnapshotInfoProto.createTime");
    target = stream->WriteStringMaybeAliased(6, this->_internal_createtime(),
                                             target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::
        InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Hdfs.Internal.SnapshotInfoProto)
  return target;
}

size_t SnapshotInfoProto::RequiredFieldsByteSizeFallback() const {
  // @@protoc_insertion_point(required_fields_byte_size_fallback_start:Hdfs.Internal.SnapshotInfoProto)
  size_t total_size = 0;

  if (_internal_has_snapshotname()) {
    // required string snapshotName = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotname());
  }

  if (_internal_has_snapshotroot()) {
    // required string snapshotRoot = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotroot());
  }

  if (_internal_has_owner()) {
    // required string owner = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_owner());
  }

  if (_internal_has_group()) {
    // required string group = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_group());
  }

  if (_internal_has_createtime()) {
    // required string createTime = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_createtime());
  }

  if (_internal_has_permission()) {
    // required .Hdfs.Internal.FsPermissionProto permission = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *permission_);
  }

  return total_size;
}
size_t SnapshotInfoProto::ByteSizeLong() const {
  // @@protoc_insertion_point(message_byte_size_start:Hdfs.Internal.SnapshotInfoProto)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) ==
      0) {  // All required fields are present.
    // required string snapshotName = 1;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotname());

    // required string snapshotRoot = 2;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_snapshotroot());

    // required string owner = 4;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_owner());

    // required string group = 5;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_group());

    // required string createTime = 6;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                this->_internal_createtime());

    // required .Hdfs.Internal.FsPermissionProto permission = 3;
    total_size +=
        1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
                *permission_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SnapshotInfoProto::MergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_merge_from_start:Hdfs.Internal.SnapshotInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  const SnapshotInfoProto* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SnapshotInfoProto>(&from);
  if (source == nullptr) {
    // @@protoc_insertion_point(generalized_merge_from_cast_fail:Hdfs.Internal.SnapshotInfoProto)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
    // @@protoc_insertion_point(generalized_merge_from_cast_success:Hdfs.Internal.SnapshotInfoProto)
    MergeFrom(*source);
  }
}

void SnapshotInfoProto::MergeFrom(const SnapshotInfoProto& from) {
  // @@protoc_insertion_point(class_specific_merge_from_start:Hdfs.Internal.SnapshotInfoProto)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      snapshotname_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.snapshotname_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      snapshotroot_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.snapshotroot_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      owner_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.owner_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      group_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.group_);
    }
    if (cached_has_bits & 0x00000010u) {
      _has_bits_[0] |= 0x00000010u;
      createtime_.AssignWithDefault(
          &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
          from.createtime_);
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_permission()
          ->::Hdfs::Internal::FsPermissionProto::MergeFrom(
              from._internal_permission());
    }
  }
}

void SnapshotInfoProto::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  // @@protoc_insertion_point(generalized_copy_from_start:Hdfs.Internal.SnapshotInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SnapshotInfoProto::CopyFrom(const SnapshotInfoProto& from) {
  // @@protoc_insertion_point(class_specific_copy_from_start:Hdfs.Internal.SnapshotInfoProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotInfoProto::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  if (_internal_has_permission()) {
    if (!permission_->IsInitialized()) return false;
  }
  return true;
}

void SnapshotInfoProto::InternalSwap(SnapshotInfoProto* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  snapshotname_.Swap(
      &other->snapshotname_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  snapshotroot_.Swap(
      &other->snapshotroot_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  owner_.Swap(&other->owner_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  group_.Swap(&other->group_,
              &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
              GetArenaNoVirtual());
  createtime_.Swap(
      &other->createtime_,
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArenaNoVirtual());
  swap(permission_, other->permission_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotInfoProto::GetMetadata() const {
  return GetMetadataStatic();
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace Internal
}  // namespace Hdfs
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::ExtendedBlockProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::ExtendedBlockProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::ExtendedBlockProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::DatanodeIDProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeIDProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::DatanodeIDProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::DatanodeInfosProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeInfosProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::DatanodeInfosProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::DatanodeInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::DatanodeInfoProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::DatanodeInfoProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::ContentSummaryProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::ContentSummaryProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::ContentSummaryProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::CorruptFileBlocksProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::CorruptFileBlocksProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::CorruptFileBlocksProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::FsPermissionProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::FsPermissionProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::FsPermissionProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::StorageUuidsProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::StorageUuidsProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::StorageUuidsProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::LocatedBlockProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::LocatedBlockProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::LocatedBlockProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::DataEncryptionKeyProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::DataEncryptionKeyProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::DataEncryptionKeyProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::FileEncryptionInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::FileEncryptionInfoProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::FileEncryptionInfoProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::PerFileEncryptionInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::PerFileEncryptionInfoProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::PerFileEncryptionInfoProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::ZoneEncryptionInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::ZoneEncryptionInfoProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::ZoneEncryptionInfoProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::CipherOptionProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::CipherOptionProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::CipherOptionProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::LocatedBlocksProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::LocatedBlocksProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::LocatedBlocksProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::HdfsFileStatusProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::HdfsFileStatusProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::HdfsFileStatusProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::FsServerDefaultsProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::FsServerDefaultsProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::FsServerDefaultsProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::DirectoryListingProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::DirectoryListingProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::DirectoryListingProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::SnapshottableDirectoryStatusProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshottableDirectoryStatusProto>(
    Arena* arena) {
  return Arena::CreateInternal<
      ::Hdfs::Internal::SnapshottableDirectoryStatusProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::SnapshottableDirectoryListingProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshottableDirectoryListingProto>(
    Arena* arena) {
  return Arena::CreateInternal<
      ::Hdfs::Internal::SnapshottableDirectoryListingProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::SnapshotDiffReportEntryProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotDiffReportEntryProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::SnapshotDiffReportEntryProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::SnapshotDiffReportProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotDiffReportProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::SnapshotDiffReportProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::StorageInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::StorageInfoProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::StorageInfoProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::NamenodeRegistrationProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::NamenodeRegistrationProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::NamenodeRegistrationProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::CheckpointSignatureProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::CheckpointSignatureProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::CheckpointSignatureProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::NamenodeCommandProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::NamenodeCommandProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::NamenodeCommandProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::CheckpointCommandProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::CheckpointCommandProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::CheckpointCommandProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::BlockProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::BlockProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::BlockProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::BlockWithLocationsProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::BlockWithLocationsProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::BlockWithLocationsProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::BlocksWithLocationsProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::BlocksWithLocationsProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::BlocksWithLocationsProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::RemoteEditLogProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::RemoteEditLogProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::RemoteEditLogProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::RemoteEditLogManifestProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::RemoteEditLogManifestProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::RemoteEditLogManifestProto>(
      arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::NamespaceInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::NamespaceInfoProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::NamespaceInfoProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::BlockKeyProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::BlockKeyProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::BlockKeyProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::ExportedBlockKeysProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::ExportedBlockKeysProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::ExportedBlockKeysProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::RecoveringBlockProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::RecoveringBlockProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::RecoveringBlockProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::VersionRequestProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::VersionRequestProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::VersionRequestProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::VersionResponseProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::VersionResponseProto>(
    Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::VersionResponseProto>(arena);
}
template <>
PROTOBUF_NOINLINE ::Hdfs::Internal::SnapshotInfoProto*
Arena::CreateMaybeMessage<::Hdfs::Internal::SnapshotInfoProto>(Arena* arena) {
  return Arena::CreateInternal<::Hdfs::Internal::SnapshotInfoProto>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
